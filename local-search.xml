<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>组合数学</title>
    <link href="/posts/55396/"/>
    <url>/posts/55396/</url>
    
    <content type="html"><![CDATA[<h2 id="容斥">容斥</h2><h3 id="折线法">折线法</h3><p>定义变换 <span class="math inline">\(T_l:\mathbb{R}^2 \mapsto\mathbb{R}^2\)</span> 为关于直线 <span class="math inline">\(l\)</span>镜射（轴对称）。</p><h4 id="两条直线">两条直线</h4><p>感觉骗我呢题解里说的似乎不是很易于理解（不过这里也可能不怎么好理解就是了）。</p><p>考虑如下问题：如图，记录点 <span class="math inline">\(A\)</span>到点 <span class="math inline">\(B\)</span> 的路径条数，要求不能碰到直线<span class="math inline">\(l_1\)</span> 或者 <spanclass="math inline">\(l_2\)</span>。 <img src="/img/组合数学1.png"alt="平面直角坐标系" /></p><p>先考虑对路径编号。我们一次写下路径与哪条直线相交（与 <spanclass="math inline">\(l_1\)</span> 相交就写下 <spanclass="math inline">\(1\)</span>，与 <spanclass="math inline">\(l_2\)</span> 相交就写下 <spanclass="math inline">\(2\)</span>），对于连续的一段 <spanclass="math inline">\(1\)</span> 或 <spanclass="math inline">\(2\)</span>，我们只保留其中一个。考虑一条路径。如下图所示。 <img src="组合数学2.png" />这条直线先与 <spanclass="math inline">\(l_2\)</span> 有 <spanclass="math inline">\(2\)</span> 个交点，然后与 <spanclass="math inline">\(l_1\)</span> 有 <spanclass="math inline">\(2\)</span> 个交点。依次写下来，就是 <spanclass="math inline">\(2211\)</span>，连续的两个 <spanclass="math inline">\(2\)</span> 和 <spanclass="math inline">\(1\)</span> 只保留 <spanclass="math inline">\(1\)</span> 个，最后我们将其记作 <spanclass="math inline">\(21\)</span>。</p><p>显然所有的路径都可以编号为一个 <spanclass="math inline">\(1,2\)</span> 交替出现的序列，记这个序列为 <spanclass="math inline">\(X\)</span>。令 <spanclass="math inline">\(f(Y)\)</span> 为以 <spanclass="math inline">\(Y\)</span>为前缀的路径条数。显然，最后符合条件的路径个数就是<spanclass="math display">\[\begin{pmatrix}n+m \\m\end{pmatrix}-f(1)-f(2)\]</span> 考虑计算。先来考虑 <spanclass="math inline">\(f(1)\)</span>。仿照一条直线的情况，我们取和 <spanclass="math inline">\(l_1\)</span> 的第一个交点，将这之后的路径关于<span class="math inline">\(l_1\)</span> 镜射。另 <spanclass="math inline">\(B^\prime=T_{l_1}(B)\)</span>。计算 <spanclass="math inline">\(A\)</span> 到 <spanclass="math inline">\(B^\prime\)</span> 的路径条数，这个就是从 <spanclass="math inline">\(A\)</span> 到 <spanclass="math inline">\(B\)</span> 并且至少碰到一次 <spanclass="math inline">\(l_1\)</span>的条数。注意，我们只考虑了<strong>至少</strong>碰到 <spanclass="math inline">\(1\)</span> 次，而没有保证第一次就碰到 <spanclass="math inline">\(l_1\)</span>。考虑路径在和 <spanclass="math inline">\(l_1\)</span> 第一次相交之前的部分。</p><ul><li>之前的部分和谁都没有相交。也就是说，第一次碰到的就是 <spanclass="math inline">\(l_1\)</span>。这类路径的个数就是 <spanclass="math inline">\(f(1)\)</span>。</li><li>根据定义，这部分路径是在和 <span class="math inline">\(l_1\)</span>第一次相交之前。因此显然不可能和 <spanclass="math inline">\(l_1\)</span> 相交。</li><li>之前的部分和 <span class="math inline">\(l_2\)</span>相交了。此类路径的条数是 <spanclass="math inline">\(f(21)\)</span>。下图就是其中一条：<imgsrc="/img/组合数学4.png" /></li></ul><p>因此，这样算出来的路径条数实际上是 <spanclass="math inline">\(f(1)+f(21)\)</span>。因此我们需要减去 <spanclass="math inline">\(f(21)\)</span>。</p><p>我们可以考虑找到路径中第一次 <span class="math inline">\(21\)</span>出现的位置（注意，不是第一次和 <span class="math inline">\(l_1\)</span>相交也不是第一次和 <span class="math inline">\(l_2\)</span>相交），先将重点关于 <span class="math inline">\(l_1\)</span>镜射，再关于 <span class="math inline">\(l_2\)</span> 镜射得到 <spanclass="math inline">\(B^{\prime\prime}\)</span>，计算 <spanclass="math inline">\(A\)</span> 到 <spanclass="math inline">\(B^{\prime\prime}\)</span>的路径条数。和上面一样，由于我们不知道之前是否与两条直线相交过，因此这样算出来的路径条数实际上是<span class="math inline">\(f(21)+f(121)\)</span>。</p><p>继续镜射，直到某个时刻镜射后的点 <spanclass="math inline">\(B\)</span> 不再第一象限内，此时路径条数就是 <spanclass="math inline">\(0\)</span>。然后将其一路回带，就可以算出 <spanclass="math inline">\(f(1)\)</span> 的值。<spanclass="math inline">\(f(2)\)</span> 也是类似的流程，不再赘述。对于 <spanclass="math inline">\(l_1:y=x+a,l_2:y=x+b,B(n,m)\)</span>的情况，复杂度为 <spanclass="math inline">\(O(\dfrac{n+m}{|a-b|})\)</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线段树小结</title>
    <link href="/posts/20874/"/>
    <url>/posts/20874/</url>
    
    <content type="html"><![CDATA[<p>本文主要是对线段树在序列上的应用的简单讲解，并不涉及复杂的线段树应用。</p><h2 id="从分治说起">从分治说起</h2><p>众所周知，分治是一种常见的算法。序列上的分治通常是这种形式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">result <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">auto</span> resl = <span class="hljs-built_in">solve</span>(l, mid), resr = <span class="hljs-built_in">solve</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(resl, resr)<br>&#125;<br></code></pre></td></tr></table></figure> 接下来考虑多次查询的情况。有的时候，我们不能接受调用多次<code>solve</code> 的复杂度，因此要考虑优化。</p><p>首先，最简单的想法就是记忆化，然而问题在于，只需要稍微改变一下一开始询问的<code>l,r</code>，最后调用的结果就会截然不同，永不上缓存的结果。因此，我们需要想方法增加重叠的子问题。</p><p>假如 <code>merge</code>的实现<strong>分割点位置无关</strong>的话，将区间如何分成两段其实并不重要。我们可以先调用一次<code>solve(1,n)</code>，把递归调用的 <code>solve</code>的答案记录下来，然后使用保存下来的答案将对应的区间拼出来。如下图所示。<img src="/img/Pasted%20image%2020250517134545.png"alt="简易线段树示意图" /> 如上图蓝色区域所示，区间 <spanclass="math inline">\([2,6]\)</span> 可以拆成 <spanclass="math inline">\([2,2],[3,3],[4,5],[6,6]\)</span>几个区间的结果合并起来。通常来说这样最多可以将区间分成 <spanclass="math inline">\(O(\log n)\)</span>个区间。注意到被保存下来的每个区间恰好对应两个区间，将每个保存下来的区间作为一个结点，向两个子区间连边，就形成了一颗二叉树。这颗二叉树就是线段树。</p><div class="note note-success">            <p><strong>TIP</strong> 实现<br /> 对于二叉树的存储，我们可以开一个数组 <code>a</code>，每个结点 <code>a[i]</code> 对应的左右孩子分别对应 <code>a[i*2]</code> 和 <code>a[i*2+1]</code>。虽然线段树的结点个数最多只有 <span class="math inline">\(2n\)</span> 个，但是这种编号方式最大编号可以达到 <span class="math inline">\(4n\)</span>，需要开 <span class="math inline">\(4\)</span> 倍空间。</p>           </div><p>这里是一个参考的区间 <span class="math inline">\(\max\)</span> 实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    ll l, r;<br>    tag t; <span class="hljs-comment">//稍后解释</span><br>    ll maxn;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">leaf</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> l == r; &#125;<br>&#125;;<br><br><span class="hljs-function">ll <span class="hljs-title">lc</span><span class="hljs-params">(ll x)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x; &#125;<br><span class="hljs-function">ll <span class="hljs-title">rc</span><span class="hljs-params">(ll x)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>; &#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll p, ll l, ll r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tree[p].<span class="hljs-built_in">leaf</span>()) &#123;<br>        <span class="hljs-keyword">return</span> tree[p].maxn;<br>    &#125;<br>    ll mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    ll res = <span class="hljs-number">-0x3f3f3f3f3f3f3f3f</span>;<br>    <span class="hljs-built_in">spread</span>(p); <span class="hljs-comment">//稍后解释</span><br>    <span class="hljs-keyword">if</span> (l &lt;= mid) &#123;<br>        res = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">query</span>(<span class="hljs-built_in">lc</span>(p), l, r), res);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt;= r) &#123;<br>        res = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">query</span>(<span class="hljs-built_in">rc</span>(p), l, r), res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="修改">修改</h3><p>显然线段树的功能不止于此。它还可以很方便地支持修改。</p><h4 id="单点修改">单点修改</h4><p>注意到加入修改序列上的一个点 <spanclass="math inline">\(pos\)</span>，受到影响的只有结点 <spanclass="math inline">\([pos,pos]\)</span> 到根节点 <spanclass="math inline">\([1,n]\)</span> 的 <spanclass="math inline">\(O(\log n)\)</span>个结点。对于每个结点的更新，在它的子节点更新完之后只需要在调用一次<code>merge</code> 即可。因此实际上我们仅仅是调用了 <spanclass="math inline">\(O(\log n)\)</span> 次 <code>merge</code>而已。假设 <code>merge</code> 是 <spanclass="math inline">\(O(1)\)</span> 的，单点修改的复杂度就是 <spanclass="math inline">\(O(\log n)\)</span>。</p><h4 id="区间修改">区间修改</h4><p>显然不可能对于区间中的每个点都修改。参考询问，将区间分成 <spanclass="math inline">\(O(\log n)\)</span>个子区间，对于每个子区间计算修改带来的代价。我们注意到<strong>并不是每个结点最后都会被用到</strong>，因此，对于这些子区间的子节点，我们可以考虑延迟更新结点，先在这些结点上打一个标记，仅当需要使用的时候再根据标记更新（“下传标记”）。这就是延迟标记。<div class="note note-success">            <p><strong>TIP</strong> 实现<br /> 更新时，如果子节点原本就有标记，需要将标记合并，而不是简单的替换（尽管对于某些题目这两个操作是等价的）。对于标记十分复杂的情况，可以考虑定义一个结构体 <code>tag</code>，重载 <code>operator+</code> 来计算一个 <code>tag</code> 对另一个 <code>tag</code> 的影响。同理，如果合并两个子节点的信息极为复杂，可以定义一个 <code>update</code> 函数来更新结点信息。另外，如果实现了区间修改，就没必要实现单点修改了。</p>           </div> 参考实现（以区间加乘为例）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tag</span> &#123;<br>    ll times;<br>    ll add;<br>    <span class="hljs-built_in">tag</span>() &#123;<br>        times = <span class="hljs-number">1</span>;<br>        add = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">tag</span>(ll _times, ll _add) : <span class="hljs-built_in">times</span>(_times), <span class="hljs-built_in">add</span>(_add) &#123;&#125;<br>    tag <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> tag &amp;b) &#123;<br>        times *= b.times;<br>        add *= b.times;<br>        add += b.add;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll p)</span> </span>&#123; tree[p].maxn = <span class="hljs-built_in">max</span>(tree[<span class="hljs-built_in">lc</span>(p)].maxn, tree[<span class="hljs-built_in">rc</span>(p)].maxn); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spread</span><span class="hljs-params">(ll p)</span> </span>&#123;<br>    tree[<span class="hljs-built_in">lc</span>(p)].t += tree[p].t;<br>    tree[<span class="hljs-built_in">lc</span>(p)].maxn *= t.times;<br>    tree[<span class="hljs-built_in">lc</span>(p)].maxn += t.add;<br>    tree[<span class="hljs-built_in">rc</span>(p)].t += tree[p].t;<br>    tree[<span class="hljs-built_in">rc</span>(p)].maxn *= t.times;<br>    tree[<span class="hljs-built_in">rc</span>(p)].maxn += t.add;<br>    tree[p].t = <span class="hljs-built_in">tag</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll p, ll l, ll r, tag op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tree[p].<span class="hljs-built_in">leaf</span>()) &#123;<br>        tree[p].t += op;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ll mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">spread</span>(p);<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) &#123;<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-built_in">lc</span>(p), l, r, op);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt;= r) &#123;<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-built_in">rc</span>(p), l, r, op);<br>    &#125;<br>    <span class="hljs-built_in">update</span>(p);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="动态开点线段树">动态开点线段树</h3><p>当维护的区间过于庞大时（例如，需要在 <spanclass="math inline">\(1\times 10 ^9\)</span> 的值域上维护信息时），<spanclass="math inline">\(4\)</span>倍的空间变得难以承受。然而，并不是每个结点最后都会使用。因此，我们只在使用的时候才给这个点分配空间，这就是动态开点。此时需要在结点上记录左右子树的下标。通常采用数组加<code>new_node</code> 函数来进行。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node tree[N*<span class="hljs-number">60</span>];<span class="hljs-comment">// 此处大小需要自行计算。</span><br>ll cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//使用时：</span><br>tree[p].lc = cnt++;<br>tree[tree[p].lc] = <span class="hljs-built_in">node</span>();<br><span class="hljs-comment">//...其他初始化操作</span><br></code></pre></td></tr></table></figure> <div class="note note-success">            <p><strong>TIP</strong> 实现<br /> 应当避免使用 <code>std::vector</code> 来实现动态开点线段树。原因是 <code>std::vector</code> 的 <code>push_back</code> 会使迭代器失效，在递归过程中造成一系列问题。</p>           </div></p><h3 id="参考题目">参考题目</h3><p>这些题目是用于加深理解的。限于篇幅，并不能一一讲解，可以参考对应题目的题解。</p><ul><li><a href="https://www.luogu.com.cn/problem/P1253">洛谷 P1253</a>需要厘清如何合并标记。</li><li><a href="https://www.luogu.com.cn/problem/P4198">洛谷 P4198</a>虽然在讲解中我们都假设 <code>merge</code> 或者 <code>update</code> 是<span class="math inline">\(O(1)\)</span>的，但实际上并非如此，只要最后的复杂度可以接受（具体题目具体分析）都可以使用。这题可以先考虑如何使用分治实现（如何合并两个区间的信息），在借助线段树的结构维护信息，优化复杂度。此外，一道题需要维护的信息不止一种，因此查询也可以有很多种。</li><li><a href="https://www.luogu.com.cn/problem/P7453">洛谷 P7453</a>这道题的前置知识是矩阵。更加复杂的更新与标记下传。</li></ul><h3 id="可持久化线段树">可持久化线段树</h3><p>可持久化线段树可以支持在线的修改在历史版本上的修改，查询。最简单的方法就是每个修改新开一颗树，显然时空双飞。</p><p>正如我们之前提到的，单点修改最多影响 <spanclass="math inline">\(O(\log n)\)</span> 个结点。因此，我们只需要将这<span class="math inline">\(O(\log n)\)</span>个结点复制一份，其余结点不变即可。具体的，假如当前修改到结点 <spanclass="math inline">\(p\)</span>，结点 <spanclass="math inline">\(p\)</span>的左子树是受到影响的，则可以复制一份结点 <spanclass="math inline">\(p\)</span>，其左子节点为复制一份后并修改的左子节点，有子节点为原先的右子节点。如果觉得有点抽象，可以看看<a href="https://oi-wiki.org/ds/persistent-seg/">OI-Wiki对应页面</a>的这张图：<imgsrc="/img/Pasted%20image%2020250517162645.png"alt="可持久化线段树示意图" /> 单次修改的时间复杂度仍是 <spanclass="math inline">\(O(\log n)\)</span>，空间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>。</p><p>可持久化线段树的一个常见的用法是对于 <spanclass="math inline">\((l,r)\)</span> 的询问将其转化成在 <spanclass="math inline">\(r\)</span> 时刻的线段树查询一个和 <spanclass="math inline">\(l\)</span> 有关的东西。结合例题来说一下。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-59ea1d47" role="button" aria-expanded="false" aria-controls="collapse-59ea1d47">        <div class="fold-arrow">▶</div>INFO 例题      </div>      <div class="fold-collapse collapse" id="collapse-59ea1d47">        <div class="fold-content">          <p><a href="https://www.luogu.com.cn/problem/P1972">洛谷 P1962</a> 改。 给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A_i\)</span>，<span class="math inline">\(q\)</span> 次询问，每次回答 <span class="math inline">\([l,r]\)</span> 之间的数去重后的个数。<strong>强制在线</strong>。 <span class="math inline">\(n,q\leq 1\times 10^6\)</span>。</p>         </div>      </div>    </div><p>考虑就是扫描一遍数组，记录每个数上次出现的位置。假设数字 <spanclass="math inline">\(x\)</span> 上一次出现在 <spanclass="math inline">\(prev_x\)</span> 的位置，也就是 <spanclass="math inline">\(A_{prev_x}=x\)</span>，维护一个数组 <spanclass="math inline">\(cnt\)</span>，将 <spanclass="math inline">\(cnt_{prev_x}\)</span> 加上 <spanclass="math inline">\(1\)</span>。扫描到 <spanclass="math inline">\(r\)</span> 时，<spanclass="math inline">\(\sum_{i=l}^r cnt_i\)</span> 就是答案。</p><p>接下来，将这个 <span class="math inline">\(cnt\)</span>数组移到线段树上维护，利用可持久化线段树支持历史版本的查询，这道题就做完了。扫描的复杂度为<span class="math inline">\(O(n\log n)\)</span>，询问 <spanclass="math inline">\(O(q\log n)\)</span>。</p><h3 id="线段树二分">线段树二分</h3><p>注意到线段树将区间分为左右两个的方式很适合二分。线段数二分就是在线段树上二分。具体的方法是首先检查左子节点的信息是否符合要求，如果是则递归到左子节点，否则递归到右子节点。</p><p>例如，我们要查询一颗权值线段树上第 <spanclass="math inline">\(k\)</span> 大的数，就可以这样：</p><ul><li>查询左子节点数的总数 <spanclass="math inline">\(sum_l\)</span>。</li><li><span class="math inline">\(sum_l\geq k\)</span>，查询左子节点第<span class="math inline">\(k\)</span> 大的数。</li><li><span class="math inline">\(sum_l\lt k\)</span>，查询右子节点第<span class="math inline">\(k-sum_l\)</span> 大的数。</li></ul><p>线段树二分通常与可持久化线段树一起来对区间进行询问。比方说下面这个例题：求区间<span class="math inline">\(\operatorname{mex}\)</span>（<ahref="https://www.luogu.com.cn/problem/P4137">洛谷 P4137</a>）。</p><p>考虑一个数没有在一个区间 <span class="math inline">\([l,r]\)</span>出现意味着什么。意味着这个数 <span class="math inline">\(x\)</span>上一次出现的位置 <span class="math inline">\(prev_x\ltl\)</span>。考虑像上一题一样从左到右扫描，维护每个数上次出现的位置 <spanclass="math inline">\(prev_x\)</span>。这次，我们利用线段树维护 <spanclass="math inline">\(prev_x\)</span>数组，并且维护区间最小值。查询的时候，在 <spanclass="math inline">\(rt_r\)</span> 上进行如下操作：</p><ul><li>查询左子节点的最小值 <spanclass="math inline">\(min_l\)</span>。</li><li><span class="math inline">\(min_l\ltl\)</span>，说明左子节点至少有一个数没有在区间内出现，向左递归。</li><li>否则，说明左子节点的左右数都出现了，向右侧递归。</li></ul><p>单次复杂度 <span class="math inline">\(O(\log n)\)</span>。</p><h3 id="线段树分治">线段树分治</h3><h4 id="标记永久化">标记永久化</h4><p>如果修改之间<strong>支持交换律</strong>，那么可以不下传标记，在询问时统计经过的标记对结果的影响。这个技巧在部分题目中相当有用。</p><p>例如：<a href="https://www.luogu.com.cn/problem/AT_abc342_g">AtCoderAT_abc342_g</a>。需要实现区间取 <spanclass="math inline">\(\max\)</span>，删除操作以及查询。对于区间取 <spanclass="math inline">\(\max\)</span>，我们在对应的节点上维护一个<code>mutiset</code>（注意标记可能一样），查询的时候对于路径上的节点上的<code>mutiset</code> 中的最大值取 <spanclass="math inline">\(\max\)</span>即可。删除时只需要找到对应的节点将标记 <code>erase</code> 即可。</p><h4 id="线段树分治-1">线段树分治</h4><p>接下来讲解线段树分治。考虑标记永久化，如果你需要在最后一次性询问每个下标该怎么办？要知道，并不是每道题目都可以只考虑节点上标记的其中一种一个造成的影响，有时你必须考虑所有标记（稍后你会看到）。考虑你查询完下标为<span class="math inline">\(1\)</span> 时的答案，接下来要询问下标为<span class="math inline">\(2\)</span>的答案该怎么办？你只需要退回叶子节点 <spanclass="math inline">\([1,1],[2,2]\)</span> 的 <spanclass="math inline">\(\operatorname{lca}\)</span>并撤销沿途标记造成的影响，然后走到节点 <spanclass="math inline">\([2,2]\)</span>并考虑沿途标记即可。接下来用类似的方法到 <spanclass="math inline">\([3,3],[4,4]\)</span>。我们注意到这恰好构成了一次DFS的过程，你只需要在进入节点时考虑节点标记带来的影响，离开时撤销即可。</p><p>这就是线段树分治，一种离线算法，可以解决此类问题：动态插入，删除元素，询问一个问题（所有询问都相同）。线段树分治可以将插入和删除操作转化为插入和撤销操作。通常来说撤销操作都是较好实现的，只需要记录操作前的数据，撤销时还原即可。</p><p>线段树分治不仅可以运用在序列上，也可以运用在其他维度，比如时间。这也是线段树分治较为常见的用途。通过将插入和删除转化为时间上存在的区间，在线段树对应的节点上打上标记，最后一次DFS 求出每个时间上的结果。</p><p>以<a href="https://www.luogu.com.cn/problem/P5787">洛谷P5787</a>为例，需要维护一个扩展域并查集来维护二分图。对于每条边，记录其存在时间<span class="math inline">\([l,r]\)</span>，意味着在第 <spanclass="math inline">\(l\)</span> 次操作时加入，第 <spanclass="math inline">\(r+1\)</span>次操作时删除。在线段树上对应的结点上打个标记。接下来遍历线段树，进入某个结点时，将这个结点有标记的所有边加入并查集，到叶子节点时判断是否存在一个点的两个域在同一个集合里，在离开时撤销。</p><div class="note note-warning">            <p><strong>WARNING</strong> 实现<br /> 对于需要撤销的并查集，<strong>不能使用路径压缩</strong>，复杂度是假的。</p>           </div><h3 id="线段树合并与分裂">线段树合并与分裂</h3><p>权值线段树（通常是动态开点）支持合并与分裂。先说合并。</p><h4 id="线段树合并">线段树合并</h4><p>线段树合并的过程是这样的。</p><ul><li>同步遍历两颗线段树。<ul><li>如果只有一颗线段树上有这个节点，那么就直接将这个节点接在合并后的线段树上。</li><li>如果两个都有，就递归合并左右节点。</li><li>更新节点信息。</li></ul></li></ul><p>下面是参考代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">merge</span><span class="hljs-params">(ll p1, ll p2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> p2;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p2 == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> p1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tree[p1].l == tree[p1].r) &#123;<br>        tree[p1].cnt += tree[p2].cnt;<br>        <span class="hljs-keyword">return</span> p1;<br>    &#125;<br>    tree[p1].lc = <span class="hljs-built_in">merge</span>(tree[p1].lc, tree[p2].lc);<br>    tree[p1].rc = <span class="hljs-built_in">merge</span>(tree[p1].rc, tree[p2].rc);<br>    <span class="hljs-built_in">update</span>(p1);<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设两个线段树的点集为 <spanclass="math inline">\(A,B\)</span>，合并这两颗线段树的复杂度为 <spanclass="math inline">\(O(|A\cup B|)\)</span>。以下是简要证明。</p><ul><li>首先考虑共有的节点。显然需要 <span class="math inline">\(O(|A\cupB|)\)</span>。</li><li>接下来考虑这些节点的子节点。显然最坏情况下一个共有节点有两个子节点都不是共有的，需要<span class="math inline">\(O(1)\)</span>的时间合并（直接接上去就行了）。总共是 <spanclass="math inline">\(O(|A\cup B|)\)</span>。</li><li>如果一个节点的父节点并不是共有节点，显然它会在它的某个祖先节点合并时被合并。不需要额外计算复杂度。</li></ul><p>因而总共的复杂度就是 <span class="math inline">\(O(|A\cupB|)\)</span>。</p><h4 id="线段树分裂">线段树分裂</h4><p>权值线段树也支持分裂。举个例子，加入要把权值线段树前 <spanclass="math inline">\(k\)</span>项分裂出去，就可以这样做，将分裂后左右两侧的线段树记为 <spanclass="math inline">\(A,B\)</span>：</p><ul><li>首先，考虑第 <span class="math inline">\(k\)</span>项在左节点还是右结点。<ul><li>如果在左节点，那么就将右节点接到 <spanclass="math inline">\(B\)</span> 的对应节点上，向左节点递归。</li><li>如果在右节点，那么就将左节点接到 <spanclass="math inline">\(A\)</span> 的对应节点上，向右结点递归。</li></ul></li></ul><p>参考代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(ll rt, ll new_rt, ll dp)</span> </span>&#123;<br>    <span class="hljs-comment">// 根节点 新的根节点 分割点</span><br>    tree[new_rt] = tree[rt];<br>    tree[new_rt].lc = <span class="hljs-number">-1</span>;<br>    tree[new_rt].rc = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (tree[rt].l == tree[rt].r) &#123;<br>        tree[new_rt].cnt = tree[rt].cnt - dp;<br>        tree[rt].cnt = dp;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tree[rt].lc != <span class="hljs-number">-1</span> &amp;&amp; dp &lt;= tree[tree[rt].lc].cnt) &#123;<br>        tree[new_rt].lc = <span class="hljs-built_in">new_node</span>();<br>        tree[new_rt].rc = tree[rt].rc;<br>        tree[rt].rc = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">split</span>(tree[rt].lc, tree[new_rt].lc, dp);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        tree[new_rt].rc = <span class="hljs-built_in">new_node</span>();<br>        <span class="hljs-built_in">split</span>(tree[rt].rc, tree[new_rt].rc,<br>              dp - (tree[rt].lc == <span class="hljs-number">-1</span> ? <span class="hljs-number">0</span> : tree[tree[rt].lc].cnt));<br>    &#125;<br>    <span class="hljs-built_in">update</span>(rt);<br>    <span class="hljs-built_in">update</span>(new_rt);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 单次复杂度为 <spanclass="math inline">\(O(\log n)\)</span>。显然受影响的只有沿途的 <spanclass="math inline">\(\log n\)</span> 个节点。</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 上配置 DNS 踩坑记</title>
    <link href="/posts/6757/"/>
    <url>/posts/6757/</url>
    
    <content type="html"><![CDATA[<p>最近看到了一篇<ahref="https://sh.alynx.one/posts/Who-Moved-My-DNS-Resolving-Remastered/">谁动了我的DNS 解析？（重制版）</a>，突然想起自己上次在高铁上因为没有把 dns改成路由器提供的 dns，导致无法找到上网认证的经历，于是决定好好配置一下dns。</p><p>由于众所周知的原因，ISP 提供的 DNS 服务器通常不是很靠谱，因此我用dnsmasq 和 dnscrypt-proxy 在本地跑了个 dns服务器。然而，一些内网地址却只能通过网络接口的 dns服务器提供解析（比如上网认证的页面）。因此，我们希望当查询 dns时，可以先询问本地的 dns 服务器，如果返回错误再询问接口提供的 dns。</p><p>我目前的方法是在 <code>NetworkManager.conf</code> 中设置<code>dns=none</code>，关闭 <code>systemd-resolved</code>，手动在<code>resolv.conf</code> 中设置 dns 服务器为 dnsmasq的监听地址。显然如果遇到的上网认证或者需要通过 VPN访问内网设备之类的情况就会挂。</p><p>于是，配（zhe）置（teng） DNS 之旅就开始了。</p><h2 id="networkmanager">NetworkManager</h2><p><ahref="https://wiki.archlinux.org/title/NetworkManager#DNS_management">注意到</a>NetworkManager 可以配合 dnsmasq 使用，只需要将 <code>dns</code> 设置为<code>dnsmasq</code> 即可。 编辑<code>/etc/NetworkManager/NetworkManager.conf</code>： <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Configuration file for NetworkManager.</span><br><span class="hljs-comment"># See &quot;man 5 NetworkManager.conf&quot; for details.</span><br><span class="hljs-section">[main]</span><br><span class="hljs-attr">dns</span>=dnsmasq<br></code></pre></td></tr></table></figure>停掉 <code>dnsmasq.service</code>，将 <code>/etc/dnsmasq.conf</code>软链接到<code>/etc/NetworkManager/dnsmasq.d/dnsmasq.conf</code>，然后重启<code>NetworkManager.service</code>。大功告成！<del>本文就写到这里，感谢阅读。</del></p><p>还没结束！别忘了标题是什么！</p><p>dnsmasq 的分流和 hosts的功能一切正常。然而，当我查询了几个我经常访问的域名时，dnsmasq 的返回和dnscrypt-proxy 的返回值并不一样。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">dig github.com @127.0.0.1</span><br>...<br>;; ANSWER SECTION:<br>github.com.600INA20.205.243.166<br>...<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dig github.com @127.0.0.1 -p 5533 <span class="hljs-comment">#dnscrypt 的端口</span></span><br>...<br>;; ANSWER SECTION:<br>github.com.21INA140.82.121.3<br>...<br></code></pre></td></tr></table></figure> 查阅 dnsmasq的日志<del>，翻过一大堆<code>cached github.com is xxx</code></del>，找到： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">May</span>  <span class="hljs-number">9</span> <span class="hljs-number">22</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38</span> dnsmasq[<span class="hljs-number">14956</span>]: forwarded github.com to <span class="hljs-number">127.0.0.1</span>#<span class="hljs-number">5533</span><br><span class="hljs-attribute">May</span>  <span class="hljs-number">9</span> <span class="hljs-number">22</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38</span> dnsmasq[<span class="hljs-number">14956</span>]: forwarded github.com to <span class="hljs-number">192.168.1.1</span><br><span class="hljs-attribute">May</span>  <span class="hljs-number">9</span> <span class="hljs-number">22</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38</span> dnsmasq[<span class="hljs-number">14956</span>]: forwarded github.com to fe80::<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>此时我怀疑可能是配置文件写错了。检查配置文件，发现<code>127.0.0.1#5533</code> 确实是唯一的服务器。网上有人说 dnsmasq会把网络链接提供的 dns 通过 dbus 发送给 dnsmasq，dnsmasq 将这两个 dns服务器与我指定的本地 dns 合并，同时向 <spanclass="math inline">\(3\)</span> 个 dns 服务器询问。dnsmasq会直接返回了较快返回的那个而因为本地 dns 最后用的是 cloudflare 的doh，因此速度较慢，没有被 dnsmasq 使用。</p><p>查阅了互联网发现并没有设置优先级之类的选项。因此我抛弃了在NetworkManager 中使用 dnsmasq 的想法。（还有一个原因是听说NetworkManager 拉起来的 dnsmasq会忽略部分配置文件，但不知道是真是假，我也懒得验证了）</p><h2 id="systemd-resolved">systemd-resolved</h2><p>有请下一位候选人！<br />systemd-resolved！</p><p>虽然之前配置 dnsmasq时因为端口冲突直接关掉了，但其实让这两位共存也不难。 将 dnsmasq改个端口： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim /etc/dnsmasq.conf</span><br>...<br>port=5353<br>...<br></code></pre></td></tr></table></figure> 在 <code>/etc/systemd/resolved.conf</code>中设置 dns 服务器： <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Resolve]</span><br><span class="hljs-attr">DNS</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">5353</span> [::<span class="hljs-number">1</span>]:<span class="hljs-number">5353</span><br></code></pre></td></tr></table></figure> 此时去查了下 ManPage，上面有这么一句话：</p><blockquote><p>DNS requests are sent to one of the listed DNS servers in parallel tosuitable per-link DNS servers acquired from <ahref="https://man.archlinux.org/man/systemd-networkd.service.8.en">systemd-networkd.service(8)</a>or set at runtime by external applications.</p></blockquote><p>看来这个也没办法满足我们的要求。<del>看来这个问题目前没有解决方案，本文到此结束。</del></p><p>然而测试一下，神奇的事情发生了： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">dig github.com</span> <br>...<br>;; ANSWER SECTION:<br>github.com.600INA20.205.243.166<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dig github.com</span><br>...<br>;; ANSWER SECTION:<br>github.com.22INA140.82.121.4<br>...<br></code></pre></td></tr></table></figure> 第二次查询返回了dnscrypt-proxy 给出的 ip。并且日志中也有相应的条目： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">May</span> <span class="hljs-number">10</span> <span class="hljs-number">14</span>:<span class="hljs-number">58</span>:<span class="hljs-number">52</span> dnsmasq[<span class="hljs-number">1316</span>]: reply github.com is <span class="hljs-number">140.82.121.4</span><br></code></pre></td></tr></table></figure>似乎在返回后 systemd-resolved 仍等待了所有 dns服务器的恢复，然后将所有回复整合了。而且配置文件中的 dns服务器优先级似乎要高于链接提供的 dns 服务器，完全符合我们的要求。</p><p>总之就是这么神奇的解决了。那么本文就这样结束了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP 通俗讲解</title>
    <link href="/posts/46064/"/>
    <url>/posts/46064/</url>
    
    <content type="html"><![CDATA[<p>本文原计划于 <span class="math inline">\(2024\)</span> 国庆发布。<img src="/img/Pasted%20image%2020241123223703.png" />最近有点颓，写不动题目了，来水一篇博客。</p><p>KMP 是 Knuth–Morris–Pratt 算法的简称，由 Knuth、Pratt 和 Morris 在1977年共同发布。该算法用来处理字符串匹配的问题（就是给定一个字符串，求它的所有字串中另一个字符串相等的字符串）。</p><p>网上有很多讲解 kmp 的文章了，但其实 kmp有着（自认为）更简单的理解方法。本文记文本串为 <spanclass="math inline">\(S\)</span>，模式串为 <spanclass="math inline">\(T\)</span>。</p><p>首先考虑暴力匹配的过程。 <span class="math display">\[\displaylines{S=&amp;{\color{red}{\texttt{abaaba}}}\texttt{abacbab}\\T=&amp;{\color{blue}\texttt{abaaba}}\texttt{cbab}}\]</span>如图，<span class="math inline">\(T\)</span> 匹配上了 <spanclass="math inline">\(S\)</span>的一个字串。当匹配到下一个字符的时候，你会发现下一个字符不等了，这种情况成为失配。此时暴力方法会将头指针向后移一位，然后重复上述的过程。但是，难道已经匹配上的这些字符串不能给我们提供一些额外的信息了吗？</p><p>考虑下一个可以和 <span class="math inline">\(T\)</span> 匹配上的<span class="math inline">\(S\)</span> 的字串。将前一个匹配上的字串记为<span class="math inline">\(s_1\)</span>，将新匹配的字串记作 <spanclass="math inline">\(s_2\)</span>。</p><ul><li><span class="math inline">\(s_2\)</span> 在 <spanclass="math inline">\(s_1\)</span> 内开始，在 <spanclass="math inline">\(s_1\)</span> 结束。 <spanclass="math display">\[\displaylines{S=&amp;{\color{red}{\texttt{ab}}}{\color{yellow}\texttt{a}}{\color{red}{\texttt{aba}}}\texttt{abacbab}\\T=&amp;{\color{yellow}\texttt{a}}\texttt{baabacbab}}\]</span>显然这种情况没什么用。因为这个匹配上的字串的长度甚至连原来匹配上的长度都比不上，最终自然不能匹配上整个<span class="math inline">\(T\)</span>。</li><li><span class="math inline">\(s_2\)</span> 在 <spanclass="math inline">\(s_1\)</span> 内开始，一直延伸到 <spanclass="math inline">\(s_1\)</span> 的末尾（其实就是说 <spanclass="math inline">\(s_2\)</span> 为 <spanclass="math inline">\(s_1\)</span> 的后缀）。<spanclass="math display">\[\displaylines{S=&amp;{\color{red}{\texttt{aba}}}{\color{yellow}\texttt{aba}}\texttt{abacbab}\\T=&amp;{\color{yellow}\texttt{aba}}\texttt{abacbab}}\]</span>这种情况是<strong>有可能</strong>匹配上整个串的，因为上一次匹配时就匹配到了第六个字符，因此程序处理到这里的时候也不止到后面能不能匹配上。<br />那么，这种字串有什么特点吗？<br />注意到，由于这两个字串都匹配上了 <span class="math inline">\(T\)</span>的某个前缀，因此这两个字串的前 <span class="math inline">\(i(1\lt i \lt\min(|s1|,|s2|))\)</span> 个字符是相等的。又因为 <spanclass="math inline">\(s_2\)</span> 同时也是 <spanclass="math inline">\(s_1\)</span> 的后缀，可以得到 <spanclass="math inline">\(s_2\)</span> 是 <spanclass="math inline">\(s_1\)</span> 的一段相等的前后缀（“Border“）。</li><li><span class="math inline">\(s_2\)</span> 在 <spanclass="math inline">\(s_1\)</span> 外，<spanclass="math display">\[\displaylines{S=&amp;{\color{red}{\texttt{abaaba}}}{\color{yellow}\texttt{aba}}\texttt{cbab}\\T=&amp;{\color{yellow}\texttt{aba}}\texttt{abacbab}}\]</span> 这种情况显然通过任何已知信息都无法推出了。</li></ul><p>由上述分类可以发现，下一个可能匹配上的位置只和已经匹配上的字符串有关。由于这个字符串必然是模式串的某个前缀，我们可以预处理模式串的所有前缀的Border。但是那么多 Border，选哪一个呢？容易发现，选择最长的 Border可以保证不漏。因为加入选择较短的 Border，如果较长的 Border合法，则不能再次回到较长的Border，因为每次指针都会向后面移动。而如果较短的 Border合法，必然可以通过上述方法得到。因此我们只需要预处理出模板串的最长Border 即可。</p><p>先假设求出了最长的 Border，我们又该怎么做呢？</p><p>首先，令一个指针 <span class="math inline">\(i\)</span> 指向 <spanclass="math inline">\(S\)</span>中匹配上的字符串的末尾，令已经匹配上的字符串长度为 <spanclass="math inline">\(k\)</span>，<span class="math inline">\(T\)</span>的长度为 <span class="math inline">\(j\)</span> 的前缀的最长 Border对应的前缀的末尾的位置为 <span class="math inline">\(B_j\)</span>（没有Border 则为 <span class="math inline">\(-1\)</span>）。</p><ul><li>初始化：<span class="math inline">\(i\gets 0,k\gets0\)</span>。</li><li>先暴力匹配。如果 <spanclass="math inline">\(S_{i+1}=T_{k+1}\)</span>，则 <spanclass="math inline">\(k\gets k+1,i\gets i+1\)</span>。</li><li>如果失配了，即 <spanclass="math inline">\(S_{i+k+1}\not=T_{k+1}\)</span>，将 <spanclass="math inline">\(k\gets B_k\)</span>，然后继续匹配。</li><li>如果 <span class="math inline">\(k=-1\)</span>，直接令 <spanclass="math inline">\(i\getsi+1,k\gets0\)</span>，相当于暴力匹配时失配的处理方式。</li><li>如果 <spanclass="math inline">\(k=|T|\)</span>，说明找到了一个字串。如果还要寻找更多的字串，可以<span class="math inline">\(k\gets B_k\)</span>，然后继续匹配。<br />这个过程的复杂度是 <span class="math inline">\(O(|S|)\)</span>，证明可见OI-Wiki。</li></ul><p>我们在暴力匹配是，将 <span class="math inline">\(i\)</span>自增前，将上面这个 <span class="math inline">\(i\)</span> 匹配到的最远的<span class="math inline">\(k\)</span> 记录下来。显然由于 <spanclass="math inline">\(i\)</span> 单调递增，且每次增加 <spanclass="math inline">\(1\)</span>，每个 <spanclass="math inline">\(i\)</span> 都会有一个对应的 <spanclass="math inline">\(k\)</span>。并且我们只增加了 <spanclass="math inline">\(n\)</span> 次 <spanclass="math inline">\(O(1)\)</span> 的操作，因此不会增加复杂度。</p><p>考虑这个东西的实际意义，应该是代表 <spanclass="math inline">\(S\)</span> 的长度为 <spanclass="math inline">\(i\)</span> 的前缀的后缀和 <spanclass="math inline">\(T\)</span>的前缀可以匹配到的最远距离。欸，我们发现这个东西和 Border的定义很像。<span class="math inline">\(T\)</span> 每个位置的 Border不就是 <span class="math inline">\(T\)</span> 的长度为 <spanclass="math inline">\(i\)</span> 的前缀的后缀和 <spanclass="math inline">\(T\)</span>的前缀匹配的最长距离吗（显然，这个前缀的长度并不会超过 <spanclass="math inline">\(i\)</span>——我们可以放心的将“和 <spanclass="math inline">\(T\)</span> 的长度为 <spanclass="math inline">\(i\)</span> 前缀匹配的最长距离吗”替换为“和 <spanclass="math inline">\(T\)</span>的前缀匹配的最长距离”）？我们发挥想象力，将上面这个过程中的 <spanclass="math inline">\(S\)</span> 全部换成 <spanclass="math inline">\(T\)</span>，会发生什么？</p><p>我们将初始化改成 <span class="math inline">\(B_{0}\gets-1,i\gets1,k\gets0\)</span>，假设现在正在匹配第 <spanclass="math inline">\(i\)</span> 个字符，显然此时有 <spanclass="math inline">\(k&lt;i\)</span>（显然，你匹配上的字符串不能比其中一个字符串还长）。那么，假设此时失配了，就需要令<span class="math inline">\(k\gets B_k\)</span>，而这个 <spanclass="math inline">\(k\)</span> 小于 <spanclass="math inline">\(i\)</span>，因此，<spanclass="math inline">\(B_k\)</span>在前面已经求出！这样改变程序，不但可以正常运行，甚至还可以帮我们正常求出Border（这就其他地方可以看到的“求 Border相当于对自己匹配”的意思）！类似匹配的复杂度，求 Border 的复杂度就是<span class="math inline">\(O(|T|)\)</span>。</p><p>因此 KMP 的总复杂度就是 <spanclass="math inline">\(O(|S|+|T|)\)</span>。</p><p>代码：网上太多了，因此就不给了。</p><p>全文完。</p><hr /><p>讲个笑话，我自己至今还没写过 KMP 的模板。 <imgsrc="/img/Pasted%20image%2020241207230611.png" /></p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>各类技巧总结</title>
    <link href="/posts/27204/"/>
    <url>/posts/27204/</url>
    
    <content type="html"><![CDATA[<h2 id="图">图</h2><h3 id="拆点">拆点</h3><p>拆点常常可以将较小的边权转化为若干个点和边权为 <spanclass="math inline">\(1\)</span> 的边，然后就可以利用特殊性质解决问题。例如：<ahref="http://poj.openjudge.cn/practice/1014">永远挑战</a>，要求复杂度<span class="math inline">\(O(n+m)\)</span>。注意到每条边的边权较小，可以在每次连边权为 <spanclass="math inline">\(2\)</span>的边时新建一个点，从起点连边到这个点，在从这个点连边到边的重点，然后 BFS求解。</p><h3 id="分层图">分层图</h3><p>可以将一个图分成多层，来满足表示更多状态的需要。 例如：<ahref="https://www.luogu.com.cn/problem/P4822">冻结</a> 注意到 <spanclass="math inline">\(K\)</span> 的范围较小，直接暴力将图复制 <spanclass="math inline">\(K\)</span>份，然后在两层图之间对应点连边权为原来权值一般的边，然后直接跑最短路。</p><p>实际上，该题（以及其他的分层图题目）可以用一中 DP 的方式来做。令<span class="math inline">\(dp_{i,j}\)</span> 为用了 <spanclass="math inline">\(j\)</span> 张卡片，到点 <spanclass="math inline">\(i\)</span> 的最短路径。对于每个 <spanclass="math inline">\(j\)</span>之间跑最短路，枚举在那条边用卡片进行转移。</p><h3 id="最短路相关">最短路相关</h3><p>众所周知，优先队列 BFS 和 Dijkstra（优先队列）的复杂度是 <spanclass="math inline">\(O((n+m)\log m)\)</span>的。实际上，该算法的瓶颈其实是取出每个点时对其他点进行松弛的复杂度。对于有特殊性质的图，如果可以想方法减少更新的复杂度，就可以获得复杂度更低的算法。例如：（随便想的，不知道有没有原题）</p><blockquote><p>给定 <span class="math inline">\(n\)</span> 个点，每个点 <spanclass="math inline">\(i\)</span> 都仅向一个区间 <spanclass="math inline">\([l_i,r_i]\)</span> 连有权值为 <spanclass="math inline">\(k_i\)</span> 的边。保证权值非负。求最短路。</p></blockquote><p>注意到每次需要向一个区间的结点更新期最短路，考虑使用线段树。更新时对区间对<span class="math inline">\(dis_i+k_i\)</span> 取 <spanclass="math inline">\(\min\)</span>，取出时查询最小值。容易发现对于每个点总共只需要花<span class="math inline">\(O(\log n)\)</span>的复杂度进行更新，总复杂度 <span class="math inline">\(O(n\logn)\)</span>。</p><h2 id="树">树</h2><h3 id="子树相关">子树相关</h3><p>子树的结点在 DFS 序上对应一个区间，可以利用这个性质进行计算。</p><h3 id="路径覆盖">路径覆盖</h3><p>在树上在覆盖 <span class="math inline">\(u\)</span> 到 <spanclass="math inline">\(v\)</span>的路径中统计（保证不是祖先关系），容易发现必定其中一个端点在 <spanclass="math inline">\(u\)</span> 的子树内，另一个在 <spanclass="math inline">\(v\)</span> 的子树内，可以利用 DFS序转化成二维数点问题。</p><h3 id="线段树型分治">线段树型分治</h3><p>注意：这里不是在说线段树分治。 <del>线段树也是树</del>线段树有以下性质：</p><ul><li>对于同一层的结点，其长度最多有两种。</li><li>对于一个结点，其左节点覆盖区间的长度大于等于右结点覆盖的区间长度。</li><li>线段树的子节点个数要么是 <span class="math inline">\(0\)</span>要么是 <span class="math inline">\(2\)</span>。</li></ul><p>这几点都比较容易证明。对于线段树上统计信息的题目，可以记录同一层相同长度的结点的信息，再通过这些信息得到其左子节点和右子节点的信息的和，快速得到下一层结点的信息。例如：</p><ul><li><a href="https://www.luogu.com.cn/problem/CF1905E">One-X</a></li><li><a href="https://www.luogu.com.cn/problem/P7143">[THUPC2021 初赛]线段树</a></li></ul><h2 id="数学">数学</h2><h3 id="矩阵">矩阵</h3><p>可以使用矩阵优化的题目往往有以下的性质：</p><ul><li><p>矩阵的大小较小，可以使用 <spanclass="math inline">\(O(n^3)\)</span> 级别的算法。</p></li><li><p>转移方法类似。</p></li><li><p>转移顺序较为规律，通常只以来上一个转移后的状态。</p></li><li><p>转移是线性的或可以使用广义矩阵乘法来表示。</p><h4 id="矩阵与最短路">矩阵与最短路</h4><p>对于 BF算法，可以考虑使用矩阵描述一轮松弛，接着使用矩阵快速幂来优化。例如：</p></li><li><p><a href="https://www.luogu.com.cn/problem/P6190">NOI Online #1入门组 魔法</a> 仔细看会发现这个东西似乎特别像Floyd（实际上如果先枚举中间一维在枚举其余两维就几乎完全一致）？实际上把这个矩阵的<span class="math inline">\(n\)</span> 次幂就相当于 BF 算法跑了 <spanclass="math inline">\(n\)</span>遍，其实也就是一次全源最短路。如果是暴力乘出来复杂度是 <spanclass="math inline">\(O(n^4)\)</span>，快速幂优化则是 <spanclass="math inline">\(O(n^3\log n)\)</span>。然而 Floyd 却只需要 <spanclass="math inline">\(O(n^3)\)</span>（只需要一次 <spanclass="math inline">\(n^3\)</span>的计算）。既然两者都是最短路，对于这类特殊的矩阵乘法，同方阵的 <spanclass="math inline">\(n\)</span> 次幂我们便可以用 Floyd 来优化，对于大于<span class="math inline">\(n\)</span>的幂次如果保证途中没有负环的话只要计算前 <spanclass="math inline">\(n\)</span>次即可<del>（似乎对于解这道题没什么用？）</del>。</p></li></ul><p>前 <span class="math inline">\(k\)</span>次矩阵乘法就相当于确定了边数为 <span class="math inline">\(k\)</span>的最短路，每次尝试添加一条边，确定边数为 <spanclass="math inline">\(k+1\)</span> 的最短路，实际上在进行以边数为阶段的dp（快速幂优化实际上是尝试一次扩展多条边）。而Floyd，众所周知，进行的是以经过的点为阶段的dp，两种不同的阶段造成了其不同的复杂度。<del>我较劲脑汁也每想出来这两个有什么更深层次的关系。</del>或许对于其它类似的矩阵乘法也可以用类似的方式优化？</p><h3 id="博弈论">博弈论</h3><p>通常可以使用 SG 函数来求得一方是否有必胜/必败的局面。</p><p>实际上，SG函数的构造基于一个简单的思路：如果现在的先手存在必胜局面，那他的对手（也就是上一次的先手）必定是必败局面，然后利用<span class="math inline">\(\operatorname{mex}\)</span> 方便计算。</p><p>类似的，对于需要计算出最优策略下的赢钱数目的情况，可以考虑对于先手必胜的局面计算其赢钱的多少，然后对于一个点，其权值显然为其可以通向的点的权值的相反数的最大值（因为下一个先手可以赢钱显然代表这一个先手会输钱）。形式化的，<spanclass="math inline">\(f(x)=\max\{f(y)|(x,y)\inE\}\)</span>。初始局面的权值就是最优赢钱数目。</p><p>例如：<a href="https://vjudge.net/problem/TopCoder-6802">MoneyGame</a></p><p>未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nginx 反代 apache2 webdav 踩坑记</title>
    <link href="/posts/1615/"/>
    <url>/posts/1615/</url>
    
    <content type="html"><![CDATA[<p>原本 nginx 的 webdav 跑的好好的，一放到 cloudflare tunnel后面就寄了，提示<code>COPY and MOVE with body are unsupported</code>，于是就改回了apache2 的 webdav。</p><p>首先出现问题的就是重命名。经过一番搜索，找到了<ahref="https://serverfault.com/questions/121766/webdav-rename-fails-on-an-apache-mod-dav-install-behind-nginx">这个</a>，照着改完用了一段时间，似乎就没什么问题了。</p><p>又过了一段时间，发现不能重命名带有中文字符的文件，然后再次搜索，发现要mod_encoding 这个 apache2 的mod，于是找了半天源码编译，没找到，心里还向着以前似乎单独用 apache的时候没什么问题。最后发现 debain 的仓库里就有，叫做<code>libapache2-mod-encoding</code>。</p><p>然而还是不能解决，最后直接连了 apache，发现是正常的，最后还是发现是nginx 的问题。就在帖子的下面：</p><blockquote><p>As <span class="citation" data-cites="Cnly">@Cnly</span> said, using<code>set</code> directive won’t work if there are special characters inboth the original <code>Destination</code> header and url. (I have noidea why)</p></blockquote><p>于是把第二个回答的配置抄了过来，结束了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抽象错误集锦</title>
    <link href="/posts/23684/"/>
    <url>/posts/23684/</url>
    
    <content type="html"><![CDATA[<p>本文收录自己犯过的一些离谱错误，用来引以为戒。</p><ol type="1"><li>(Acwing 121)离散化之后混用下标和离散化的数值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll tx=<span class="hljs-built_in">lower_bound</span>(x,x+rx,i+mid<span class="hljs-number">-1</span>)-x,ty=<span class="hljs-built_in">lower_bound</span>(y,y+ry,j+mid<span class="hljs-number">-1</span>)-y;<br><span class="hljs-keyword">if</span>(x[tx]&gt;i+mid||tx&gt;=rx)tx--;<br><span class="hljs-keyword">if</span>(y[ty]&gt;j+mid||ty&gt;=ry)ty--;<br>ll ans=sum[tx][ty]-(i!=<span class="hljs-number">0</span>?sum[i<span class="hljs-number">-1</span>][ty]:<span class="hljs-number">0</span>)-(j!=<span class="hljs-number">0</span>?sum[tx][j<span class="hljs-number">-1</span>]:<span class="hljs-number">0</span>)+(i!=<span class="hljs-number">0</span>&amp;&amp;j!=<span class="hljs-number">0</span>?sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]:<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(ans&gt;=c)&#123;<br>res=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">goto</span> out_of_loop;<br>&#125;<br></code></pre></td></tr></table></figure>正确写法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll tx=<span class="hljs-built_in">lower_bound</span>(x,x+rx,x[i]+mid<span class="hljs-number">-1</span>)-x,ty=<span class="hljs-built_in">lower_bound</span>(y,y+ry,y[j]+mid<span class="hljs-number">-1</span>)-y;<br><span class="hljs-keyword">if</span>(x[tx]&gt;x[i]+mid<span class="hljs-number">-1</span>||tx&gt;=rx)tx--;<br><span class="hljs-keyword">if</span>(y[ty]&gt;y[j]+mid<span class="hljs-number">-1</span>||ty&gt;=ry)ty--;<br>ll ans=sum[tx][ty]-(i!=<span class="hljs-number">0</span>?sum[i<span class="hljs-number">-1</span>][ty]:<span class="hljs-number">0</span>)-(j!=<span class="hljs-number">0</span>?sum[tx][j<span class="hljs-number">-1</span>]:<span class="hljs-number">0</span>)+(i!=<span class="hljs-number">0</span>&amp;&amp;j!=<span class="hljs-number">0</span>?sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]:<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(ans&gt;=c)&#123;<br>    res=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">goto</span> out_of_loop;<br>&#125;<br><br></code></pre></td></tr></table></figure> 其中 <code>i,j</code> 是下标，<code>x[i],y[j]</code> 是离散化之后的数。</li><li>(AT_abc356_d)组合数求法。 错误示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">c</span><span class="hljs-params">(ll p,ll n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    ll res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=p;i++)&#123;<br>        res=(res*i)%Mod;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(ll i=n;i&gt;=n-p;i--)&#123;<br>        res=(res*i)%Mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>槽点有点多。<br />首先，<span class="math inline">\(0!=1\)</span>，因此即便 <spanclass="math inline">\(n=0\)</span>，<spanclass="math inline">\(\operatorname{C}_n^p\)</span>也非零。其次，下半部分的阶乘应当时乘上乘法逆元，而不是乘上 <spanclass="math inline">\(1\times 2\cdots p\)</span>。第三，<spanclass="math inline">\([n-p,n]\)</span> 有 <spanclass="math inline">\(p+1\)</span> 个数。正确示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">c</span><span class="hljs-params">(ll p,ll n)</span></span>&#123;<br>    ll res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=p;i++)&#123;<br>        res=(res*niyuan[i])%Mod;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(ll i=n;i&gt;n-p;i--)&#123;<br>        res=(res*i)%Mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(Acwing220)线性筛等需要多个循环变量时分清每个变量是做什么的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prime_prework</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(min_prime_factor,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> min_prime_factor);<br>    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;=inp;i++)&#123;<br>        <span class="hljs-keyword">if</span>(min_prime_factor[i]==<span class="hljs-number">0</span>)&#123;<br>            phi[i]=i<span class="hljs-number">-1</span>;<br>            min_prime_factor[i]=i;<br>            primes[n]=i;<br>            n++;<br>        &#125;<br>        sum_prefix[i]=sum_prefix[i<span class="hljs-number">-1</span>]+phi[i];<br>        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;n&amp;&amp;primes[i]&lt;=min_prime_factor[j]<span class="hljs-comment">/*此处下标i,j反了*/</span>&amp;&amp;i*primes[j]&lt;=inp;j++)&#123;<br>            phi[i*primes[j]]=phi[i]*(i%primes[j]==<span class="hljs-number">0</span>?primes[j]:(primes[j]<span class="hljs-number">-1</span>));<br>            min_prime_factor[i*primes[j]]=primes[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 正确示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prime_prework</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(min_prime_factor,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> min_prime_factor);<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;=inp;i++)&#123;<br><span class="hljs-keyword">if</span>(min_prime_factor[i]==<span class="hljs-number">0</span>)&#123;<br>phi[i]=i<span class="hljs-number">-1</span>;<br>min_prime_factor[i]=i;<br>primes[n]=i;<br>n++;<br>&#125;<br>sum_prefix[i]=sum_prefix[i<span class="hljs-number">-1</span>]+phi[i];<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;n&amp;&amp;primes[j]&lt;=min_prime_factor[i]&amp;&amp;i*primes[j]&lt;=inp;j++)&#123;<br>phi[i*primes[j]]=phi[i]*(i%primes[j]==<span class="hljs-number">0</span>?primes[j]:(primes[j]<span class="hljs-number">-1</span>));<br>min_prime_factor[i*primes[j]]=primes[j];<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(AcWing258)想得太复杂了。看完题目以为要用一大堆推理分析，调了好久都没想出来。后来发现暴力就能过。（实际上不是没注意到数据范围，而是以为这道题目时限比较松）结论就是：当一个思路不太好实现时，建议换一个思路。</li><li>(Luogu P4198)开 <code>long double</code> 要开全！！ <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">cal</span><span class="hljs-params">(ll p,ll h)</span></span>&#123;<span class="hljs-comment">/**/</span>&#125; <span class="hljs-comment">// &lt;-- ll h 应为 long double h</span><br></code></pre></td></tr></table></figure>正确示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">cal</span><span class="hljs-params">(ll p,<span class="hljs-type">long</span> <span class="hljs-type">double</span> h)</span></span>&#123;<span class="hljs-comment">/**/</span>&#125;<br></code></pre></td></tr></table></figure></li><li>(Luogu P4556)检查特殊下标（比如 <spanclass="math inline">\(-1\)</span>）有没有特判。（可以用<code>fsanitize</code> 查查ub）</li><li>(LuoguP4556)还是那题，倍增法LCA记得特判第一步就移动到相同的点上的可能。</li><li>(Luogu P4556)又是那题，还是倍增法LCA,检查开的数组的大小，记住 <spanclass="math inline">\(\lceil\log_2 1\times 10^5\rceil=17\)</span>。</li><li>(Luogu P6225)写树状数组时记得不要把 <spanclass="math inline">\(pos\)</span> 和 <spanclass="math inline">\(x\)</span> 搞混了。虽然很离谱但是我已经连续两次把<span class="math inline">\(\operatorname{lowbit}(pos)\)</span> 中的<span class="math inline">\(pos\)</span> 写成 <spanclass="math inline">\(x\)</span> 了。</li><li>(Luogu P6619)还是树状数组，写 <code>pos-=lowbit(pos)</code>的时候不要把 <code>lowbit</code> 漏掉。</li><li>(Luogu P6619)倍增的时候不要直接把算出来的 <spanclass="math inline">\(\log n\)</span> 当作 <spanclass="math inline">\(i\)</span>。听起来很离谱，但是我确实这么干了。还有记得更新各个变量。</li><li>(LuoguP3834)可持久化权值线段树到叶子节点的时候记得把旧的数值复制进来。</li><li>(Luogu P7453)记得取模！！！</li><li>(Luogu P7453)区间操作记得更新路径上的节点的值！！</li><li>(Luogu P4170)递归dp如果不确定调用次数记得写记忆化！！！</li><li>(Luogu网校 T483205)一边 range-for 一边插入节点会出问题。</li><li>(Luogu网校 T483205)<code>std::unordered_map&lt;__int128,__int128&gt;</code> 会出问题，因为<code>__int128</code> 没有默认的 hash 函数。（改为<code>long long</code> 即可）</li><li>(Luogu网校 T483205)手写邻接表+hash 忘记更新下标。 错误示范：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">i128 <span class="hljs-title">query</span><span class="hljs-params">(ll i)</span></span>&#123;<br>    i128 h=((i%M)*P)%M;<br>    ll ind=head[h];<br>    <span class="hljs-keyword">while</span> (ind!=<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(ht[ind].num==i)&#123;<br>            <span class="hljs-keyword">return</span> ht[ind].val; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure> 正确示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">i128 <span class="hljs-title">query</span><span class="hljs-params">(ll i)</span></span>&#123;<br>    i128 h=((i%M)*P)%M;<br>    ll ind=head[h];<br>    <span class="hljs-keyword">while</span> (ind!=<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(ht[ind].num==i)&#123;<br>            <span class="hljs-keyword">return</span> ht[ind].val; <br>        &#125;<br>        ind=ht[ind].nxt; <span class="hljs-comment">//&lt;-- 这行少了</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(Luogu网校 T486366)多测慎用<code>memset()</code>，以及不需要频繁取模。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(t--)&#123;<br>    <span class="hljs-built_in">memset</span>(s,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> s); <span class="hljs-comment">//&lt;-- 这一行</span><br>    <span class="hljs-built_in">memset</span>(order,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> order); <span class="hljs-comment">//&lt;-- 和这一行</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    由于这两个数组是 1e7 级别的</span><br><span class="hljs-comment">    数据保证所有测试点 n 的总和为 1e7</span><br><span class="hljs-comment">    所以当 n 的规模远小于 1e7是</span><br><span class="hljs-comment">    总共的测试点组数可能会来到</span><br><span class="hljs-comment">    1e3 甚至 1e4。</span><br><span class="hljs-comment">    而这两个语句在每个测试点都会重复memset一边 1e7 的数组</span><br><span class="hljs-comment">    因此导致 TLE。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//sth else</span><br>    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;n-k<span class="hljs-number">+1</span>;i++)&#123;<br>        ans+=((i<span class="hljs-number">+1</span>)*(order[i]<span class="hljs-number">+1</span>))%(ll)(<span class="hljs-number">1e9</span><span class="hljs-number">+7</span>); <span class="hljs-comment">//&lt;-- 这里的取模是多余的，因为下一行已经取过一次摸了，而且并不会爆精度。多出来的一次取模导致常数变大 TLE</span><br>        ans%=(ll)<span class="hljs-number">1e9</span><span class="hljs-number">+7</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 正确示范：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-comment">//sth else</span><br>s[n<span class="hljs-number">+1</span>]=s[n]=<span class="hljs-number">0</span>;<span class="hljs-comment">// 最终程序最大只会访问到 n，因此只把这两个赋值就可以了。（前面的有输入）</span><br><span class="hljs-comment">//sth else</span><br>    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;n-k<span class="hljs-number">+1</span>;i++)&#123;<br>        ans+=((i<span class="hljs-number">+1</span>)*(order[i]<span class="hljs-number">+1</span>))%(ll)(<span class="hljs-number">1e9</span><span class="hljs-number">+7</span>); <span class="hljs-comment">// &lt;-- 去掉多余的取模操作</span><br>        ans%=(ll)<span class="hljs-number">1e9</span><span class="hljs-number">+7</span>;<br>    &#125;<br><span class="hljs-comment">//output...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>(Luogu P6033)这道题时间复杂度卡的很紧。有的时候构造函数可以省略。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>ull val;<br>    ull times;<br><span class="hljs-built_in">node</span>()&#123;<br>        val=times=<span class="hljs-number">0</span>; <span class="hljs-comment">//&lt;-- 此处构造函数会在声明时调用。由于数组过大(1.5e7)导致调用是会有约 50ms 的常数增加（此题时限 500ms，卡的很紧）</span><br>&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Queue</span>&#123;<br>node data[(<span class="hljs-type">int</span>)<span class="hljs-number">1.5e7</span><span class="hljs-number">+100</span>];<br>    <span class="hljs-comment">//sth</span><br><span class="hljs-comment">//在队列的push函数中已经有了对于node相关成员的修改。因此无需初始化。</span><br>&#125;<br></code></pre></td></tr></table></figure> 正确示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>ull val;<br>    ull times;<br><span class="hljs-comment">// &lt;-- 删去了构造函数</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Queue</span>&#123;<br>node data[(<span class="hljs-type">int</span>)<span class="hljs-number">1.5e7</span><span class="hljs-number">+100</span>];<br>    <span class="hljs-comment">//sth</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>(Luogu P4513)线段树的 <code>x&lt;=mid</code> 不要写成<code>mid&lt;=x</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll p,ll x,ll v)</span></span>&#123;<br><span class="hljs-comment">//sth</span><br><span class="hljs-keyword">if</span>(mid&lt;=x)&#123; <span class="hljs-comment">//&lt;-- 应为 x&lt;=mid</span><br><span class="hljs-built_in">modify</span>(<span class="hljs-built_in">lc</span>(p),x,v);<br>&#125;<br><span class="hljs-comment">//sth</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>(Luogu网校T489100)写线性筛的时候需要注意各种边界问题。（以及复制代码的时候把变量名盖全）</li><li>(Luogu网校 T491913)Floyd 算法。需要注意不能枚举通过一条边到达 <spanclass="math inline">\(k\)</span> 的点和从 <spanclass="math inline">\(k\)</span>开始通过一条边可以到达的点。具体看代码。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>ll s,t,v;<br>cin&gt;&gt;s&gt;&gt;t&gt;&gt;v;<br>G1[s].<span class="hljs-built_in">push_back</span>(&#123;v,t&#125;);<br>G2[t].<span class="hljs-built_in">push_back</span>(&#123;v,s&#125;);<br>&#125;<br><span class="hljs-comment">//do sth</span><br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s:G2[arr[i].ind])&#123; <span class="hljs-comment">//&lt;-- 这两处有误</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:G1[arr[i].ind])&#123; <span class="hljs-comment">//&lt;--</span><br><span class="hljs-comment">//do sth</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 正确写法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>ll s,t,v;<br>cin&gt;&gt;s&gt;&gt;t&gt;&gt;v;<br>G1[s].<span class="hljs-built_in">push_back</span>(&#123;v,t&#125;);<br>G2[t].<span class="hljs-built_in">push_back</span>(&#123;v,s&#125;);<br>&#125;<br><span class="hljs-comment">//do sth</span><br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(ll s=<span class="hljs-number">1</span>;s&lt;=n;s++)&#123;<br><span class="hljs-keyword">for</span>(ll t=<span class="hljs-number">1</span>;t&lt;=n;t++)&#123;<br><span class="hljs-comment">//do sth</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(校内模拟)复制粘贴：其一 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;ll T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">modint</span>&#123;<br>    ll val;<br>    <span class="hljs-built_in">modint</span>()&#123;<br>        val=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">modint</span>(ll x)&#123;<br>        val=x%T;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> modint&lt;T&gt;&amp; b)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> val==b.val;<br>    &#125;<br>    modint&lt;T&gt; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> modint&lt;T&gt; &amp;b)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">modint</span>&lt;T&gt;(val+b.val);<br>    &#125;<br>    modint&lt;T&gt; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> modint&lt;T&gt; &amp;b)&#123;<br>        val=(val+b.val)%T;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    modint&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> modint&lt;T&gt; &amp;b)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">modint</span>&lt;T&gt;(val+b.val); <span class="hljs-comment">//&lt;-- 注意这里</span><br>    &#125;<br>    modint&lt;T&gt; <span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> modint&lt;T&gt; &amp;b)&#123;<br>        val=(val*b.val)%T;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    modint&lt;T&gt; <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> modint&lt;T&gt; &amp;b)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">modint</span>&lt;T&gt;(val-b.val+((val-b.val&lt;<span class="hljs-number">0</span>)?T:<span class="hljs-number">0</span>));<br>    &#125;<br>    modint&lt;T&gt; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> modint&lt;T&gt; &amp;b)&#123;<br>        val=(val-b.val)%T;<br>        <span class="hljs-keyword">if</span>(val&lt;<span class="hljs-number">0</span>)val+=T;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>(同上)复制粘贴：其二 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll l=<span class="hljs-number">1</span>,r=sz;<br><span class="hljs-keyword">while</span> (l&lt;r) &#123;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">rotate</span>(m, mid)==<span class="hljs-built_in">rotate</span>(m, mid))&#123; <span class="hljs-comment">// &lt;-- 恒等</span><br>        l=mid<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        r=mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(没想到吧，还是一道题)字符串hash没有预处理 <code>pow</code>数组（甚至已经声明过了</li><li>(一样)二维 hash 写错数组 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span> (ll j=<span class="hljs-number">1</span>; j&lt;=m*<span class="hljs-number">2</span>; j++) &#123;<br>        G[i][j].a=(H[i<span class="hljs-number">-1</span>][j].a*P1)+H[i][j].a;<br>        G[i][j].b=(H[i<span class="hljs-number">-1</span>][j].b*P2)+H[i][j].b; <span class="hljs-comment">//&lt;-- 右侧 H[i-1][j] 应为 G[i-1][j]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(P9149) 死循环：其一 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (h &lt; v.<span class="hljs-built_in">size</span>() &amp;&amp; i == v[h].r) &#123;<br>ll t = bi.<span class="hljs-built_in">query</span>(v[h].r) - bi.<span class="hljs-built_in">query</span>(v[h].l - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (t &gt; d) &#123;<br><span class="hljs-keyword">continue</span>; <span class="hljs-comment">//&lt;-- 注意 h 并不会更新，导致死循环</span><br>&#125;<br>ll rest_w = w - nums - t, rest_d = d - t;<br>ans += <span class="hljs-built_in">C</span>(rest_d, rest_w);<br>h++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(P3527)无限递归：其一 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ull l, ull r, ull val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (r &lt; l) &#123;<br>        <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, m, val);<br>        <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, l - <span class="hljs-number">1</span>, -val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">add</span>(l, val);<br>        <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -val);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 考虑<code>l==3&amp;&amp;r==2</code>的情况，<code>add(r + 1, l - 1, -val);</code> 递归后仍然<code>r&lt;l</code>。</li><li>(P3810)使用之前记录下来的下标访问元素的时候要原数组是否更改。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">solve</span>(<span class="hljs-number">0</span>, total - <span class="hljs-number">1</span>); <span class="hljs-comment">// 这个函数是cdq分治，里边要重新排序，之前记录的下标会失效</span><br><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cnt[ans[i]] += arr[i].times;<br>&#125;<br></code></pre></td></tr></table></figure> 解决： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">solve</span>(<span class="hljs-number">0</span>, total - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">sort</span>(arr, arr + total, [](<span class="hljs-type">const</span> e &amp;a, <span class="hljs-type">const</span> e &amp;b) &#123;<span class="hljs-keyword">return</span> a.i&lt;b.i;&#125;);<span class="hljs-comment">// &lt;-- 重新排个序就好了</span><br><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cnt[ans[i]] += arr[i].times;<br>&#125;<br></code></pre></td></tr></table></figure> 补上提交记录或许更容易理解：<ahref="https://www.luogu.com.cn/record/184553459">不排序</a>，<ahref="https://www.luogu.com.cn/record/184561779">排序</a></li><li>(CSP-S 2024 T2)局部变量记得初始化！！！！！ 挂分写法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>bit b;<br><span class="hljs-comment">//do sth</span><br>&#125;<br></code></pre></td></tr></table></figure> 正确写法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    bit b;<br>    b.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-comment">//do sth</span><br>&#125;<br></code></pre></td></tr></table></figure> <spanclass="math inline">\([70,90]\to[0,40]\)</span>。 <spanclass="math inline">\([70,90]\)</span> 是因为还有一个地方写挂了。</li><li>(AT_abc280_f)带权并查集：合并时根节点分不清，没有计算出正确的权值（注释里是正确的写法）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">m</span><span class="hljs-params">(ll x, ll y, ll dis)</span> </span>&#123;<br>    ll rx = <span class="hljs-built_in">fi</span>(x), ry = <span class="hljs-built_in">fi</span>(y);<br>    <span class="hljs-keyword">if</span> (rx != ry) &#123;<br>        <span class="hljs-comment">//ll r_dis=-f[x].dis+dis+f[y].dis;</span><br>        <span class="hljs-comment">//注意这行，计算出正确的dis值</span><br>        f[rx].fa = ry;<br>        <span class="hljs-comment">//f[rx].dis = r_dis;</span><br>        f[rx].dis=dis;<br>        f[rx].inf |= f[ry].inf;<br><span class="hljs-comment">//f[ry].inf|=f[rx].inf;</span><br><span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>(CF1691F)运算符优先级，乘法比加法先： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll x)</span> </span>&#123;<br><span class="hljs-comment">//do sth</span><br>ans += <span class="hljs-built_in">modular</span>&lt;MOD&gt;(n) * <span class="hljs-built_in">C</span>(k, n) - totalc;<br>    <span class="hljs-comment">//ans += modular&lt;MOD&gt;(n) * (C(k, n) - totalc);</span><br>    <span class="hljs-comment">//就这个问题调了好久。</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(P4155)断环成链后，如果需要排序，区间长度记得 <spanclass="math inline">\(\times 2\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cin &gt;&gt; r[i].l &gt;&gt; r[i].r;<br>    <span class="hljs-keyword">if</span> (r[i].r &lt; r[i].l) &#123;<br>        r[i].r += m;<br>    &#125;<br>    r[i + n] = r[i];<br>    r[i + n].r += m, r[i + n].l += m;<br>    r[i].i = i;<br>&#125;<br><span class="hljs-built_in">sort</span>(r, r + n, [](<span class="hljs-type">const</span> range &amp;a, <span class="hljs-type">const</span> range &amp;b) &#123; <span class="hljs-keyword">return</span> a.l &lt; b.l; &#125;);<br></code></pre></td></tr></table></figure> 应改为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cin &gt;&gt; r[i].l &gt;&gt; r[i].r;<br>    <span class="hljs-keyword">if</span> (r[i].r &lt; r[i].l) &#123;<br>        r[i].r += m;<br>    &#125;<br>    r[i + n] = r[i];<br>    r[i + n].r += m, r[i + n].l += m;<br>    r[i].i = i;<br>&#125;<br><span class="hljs-built_in">sort</span>(r, r + n * <span class="hljs-number">2</span>,<br>    [](<span class="hljs-type">const</span> range &amp;a, <span class="hljs-type">const</span> range &amp;b) &#123; <span class="hljs-keyword">return</span> a.l &lt; b.l; &#125;);<br></code></pre></td></tr></table></figure></li><li>(P3065)拓扑排序是连边是通向的结点的入读加一。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (t[cur].c[<span class="hljs-built_in">to_int</span>(c)] &amp;&amp; c != x) &#123;<br>    G[<span class="hljs-built_in">to_int</span>(x)].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_int</span>(c));<br>    inc_deg[<span class="hljs-built_in">to_int</span>(x)]++; <span class="hljs-comment">// --&gt; 改为：inc_deg[to_int(c)]++;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>(CF888G)tire数搞清楚位运算。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-type">int</span> b = val &amp; (<span class="hljs-number">1</span> &lt;&lt; i);<span class="hljs-comment">//应该改为：int b = (v &gt;&gt; i) &amp; 1;</span><br>    <span class="hljs-comment">//这样并没有清楚后面的位，因此不能仅靠 1 来判断。</span><br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//do stj</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//do sth</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(CF888G)不要随便霍霍内存。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-comment">//...</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; val;<br><span class="hljs-comment">//...</span><br>&#125;;<br>node t[<span class="hljs-number">33</span> * N];<br></code></pre></td></tr></table></figure> 01-trie的一个卡内存的技巧：将原数组排序，然后在每个结点记录最左边的数和最右边的数。01-trie感觉有点像一颗特化的平衡树，每个结点实际上代表了一个区间。</li><li>(CF1824D) <code>std::vector</code> 在 <code>push_back</code>或其他修改操作后其原来的迭代器会失效，引用也会失效。 这样写也不行：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>;<br>vector&lt;node&gt; v;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>ll data;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//do sth with v;</span><br>v.<span class="hljs-built_in">push_back</span>(data);<br><span class="hljs-comment">//...</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//...</span><br>v[i].<span class="hljs-built_in">f</span>();<br></code></pre></td></tr></table></figure> 因为 <code>push_back</code> 后原本这个 <code>v[i]</code>也失效了。</li><li>(CF1824D) 线段树下传标记的函数调用不要放在新建子节点的<code>if</code> 的括号里。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spread</span><span class="hljs-params">(ll p)</span> </span>&#123;<br>ll mid = (arr[p].l + arr[p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (arr[p].lc == <span class="hljs-number">-1</span>) &#123;<br>        arr[p].lc = arr.<span class="hljs-built_in">size</span>();<br>        arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">node</span>(arr[p].l, mid));<br>        <span class="hljs-comment">//if (arr[p].t != -INF) set(arr[p].lc, arr[p].t);//而不是这里</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (arr[p].t != -INF) <span class="hljs-built_in">set</span>(arr[p].lc, arr[p].t);<span class="hljs-comment">//这里</span><br>    <span class="hljs-keyword">if</span> (arr[p].rc == <span class="hljs-number">-1</span>) &#123;<br>        arr[p].rc = arr.<span class="hljs-built_in">size</span>();<br>        arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">node</span>(mid + <span class="hljs-number">1</span>, arr[p].r));<br>        <span class="hljs-comment">//if (arr[p].t != -INF) set(arr[p].rc, arr[p].t); //而不是这里</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (arr[p].t != -INF) <span class="hljs-built_in">set</span>(arr[p].rc, arr[p].t); <span class="hljs-comment">//这里</span><br>    arr[p].t = -INF;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(校内模拟)浮点数运算一定要先乘再除。先除成一个极小的数下溢之后再做被除数会变成<code>inf</code>，先乘再除就没这个问题。</li><li>(P4281) dfs 方法预处理 lca 的 fa 数组时记得先预处理在递归。错误示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll x)</span> </span>&#123;<br>    vis[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> k : G[x]) &#123;<br>        <span class="hljs-keyword">if</span> (!vis[k]) &#123;<br>            <span class="hljs-built_in">dfs</span>(k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            fa[x][<span class="hljs-number">0</span>] = k;<br>            depth[x] = depth[k] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 正确示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll x)</span> </span>&#123;<br>    vis[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> k : G[x]) &#123;<br>        <span class="hljs-keyword">if</span> (vis[k]) &#123;<br>            fa[x][<span class="hljs-number">0</span>] = k;<br>            depth[x] = depth[k] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> k : G[x]) &#123;<br>        <span class="hljs-keyword">if</span> (!vis[k]) &#123;<br>            <span class="hljs-built_in">dfs</span>(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>(P6845)线段树下传标记的时候要<strong>合并</strong>标记而不是<strong>覆盖</strong>标记。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll p, ll val)</span> </span>&#123;<br><span class="hljs-comment">//给 p 结点对应的区间加上 val.</span><br>    node &amp;cur = t[p];<br>    cur.maxe.val += val;<br>    cur.mine.val += val;<br>    cur.max_halfe_l.val -= val;<br>    cur.max_halfe_r.val -= val;<br>    cur.tag += val; <span class="hljs-comment">//&lt;--应为： cur.tag += val;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>(P2824) P2824 破防实录（其一）：<code>erase</code> 完<code>std::set</code> 后这个迭代器会失效。不能 <code>++</code>。错误示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = beg; i != end; i++) &#123;<br>    rt = <span class="hljs-built_in">merge</span>(rt, i-&gt;rt);<br>    s.<span class="hljs-built_in">erase</span>(i)<br>&#125;<br></code></pre></td></tr></table></figure> 正确示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = beg; i != end; i++) &#123;<br>    <span class="hljs-keyword">auto</span> tmp = i;<br>    tmp--;<br>    s.<span class="hljs-built_in">erase</span>(tmp);<br>    rt = <span class="hljs-built_in">merge</span>(rt, i-&gt;rt);<br>&#125;<br></code></pre></td></tr></table></figure> 似乎还有一种写法是<code>s.erase(i++)</code>。</li><li>(P2824) P2824破防实录（其二）：遇到分类讨论的时候记得询问时也要分类。（奇怪，明明写之前还记得的）错误示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-number">1</span> + <span class="hljs-built_in">query</span>(loc.rt, q - loc.l + <span class="hljs-number">1</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure> 正确示范： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-number">1</span> + <span class="hljs-built_in">query</span>(loc.rt, loc.is_inc<br>              ? q - loc.l + <span class="hljs-number">1</span><br>                  : tree[loc.rt].cnt - (q - loc.l + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>)<br>     &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>奇数码问题初探</title>
    <link href="/posts/6079/"/>
    <url>/posts/6079/</url>
    
    <content type="html"><![CDATA[<p>最近在算法竞赛进阶指南上看到了奇数码问题，但是没讲证明。恰好最近刻上老师讲了证明，简单记录一下证明过程。证明过程需要用到映射和基本的群论知识，如果你不了解，建议先学习一下这些前置知识。本文中的复合运算符<span class="math inline">\(\circ\)</span> 有时会省略。</p><h3 id="题目简介">题目简介</h3><p>奇数码问题是一个经典的群论问题。也许你听说过数字华容道或 <spanclass="math inline">\(15\)</span> 拼图问题，那就是它最常见的变体， <spanclass="math inline">\(4\times4\)</span> 的奇数码问题。将这个问题扩展到<span class="math inline">\(n\times n\)</span>的情况就是我们要研究的奇数码问题。在这篇文章，我们主要研究它的可解性问题。</p><h3 id="可解性">可解性</h3><h3 id="赏金">赏金</h3><p>1896 年，美国著名棋手SamLoyd 曾经悬赏1000美金，来看看有没有人可以解出这个问题：<span class="math display">\[\begin{array}{|c|c|c|c|}\hline 1&amp;2&amp;3&amp;4\\\hline 5&amp;6&amp;7&amp;8\\\hline 9&amp;10&amp;11&amp;12\\\hline 13&amp;15&amp;14&amp;\\\hline\end{array}\]</span>其中只有 <span class="math inline">\(14\)</span> 和 <spanclass="math inline">\(15\)</span>是进行交换的。我们将稍后来解决这个问题。<del>你可以自己玩玩看，看看你能不你拿到这1000美元</del></p><h3 id="对换置换与轮换">对换，置换与轮换</h3><p>在解决这个问题前，我们先引入几个概念。</p><ul><li>置换，又叫排列，指的是在集合 <span class="math inline">\(S\)</span>中的双射 <span class="math inline">\(f:S \mapsto S\)</span>。例如，对于<span class="math inline">\(S=\{1,2,3\}\)</span>，定义 <spanclass="math inline">\(f(1)=3,f(2)=2,f(3)=1\)</span>，<spanclass="math inline">\(f\)</span> 就是一个置换。实际上，如果用 <spanclass="math inline">\(f(x)\)</span> 替换 <spanclass="math inline">\(x\)</span>，会发现其实集合里面每个数都出现了，只是顺序可能不同。就像这样<spanclass="math display">\[\displaylines{1&amp;2&amp;3\\\downarrow&amp;\downarrow&amp;\downarrow\\3&amp;2&amp;1}\]</span>刚刚这种表示也可以用来记录一个置换。即<spanclass="math display">\[f=\begin{pmatrix}1&amp;2&amp;3\\\downarrow&amp;\downarrow&amp;\downarrow\\3&amp;2&amp;1\end{pmatrix}\]</span>特别的，对于<span class="math inline">\(f(x)=x\)</span>这种映射也是置换，成为恒同变换或者叫恒同置换，记作 <spanclass="math inline">\(\rm{id}\)</span>。<br /></li><li>对换，顾名思义，就是只有两个元素进行了交换，其他元素不变。形式化的，<spanclass="math inline">\(f:S\mapsto S\)</span> 是对换是指存在 <spanclass="math inline">\(x,y\in S,f(x)=y,f(y)=x\)</span>，并且对于其他元素<span class="math inline">\(z\in S,f(z)=z\)</span>，我们可以用 <spanclass="math inline">\(f=(x,y)\)</span> 来表示这是一个交换 <spanclass="math inline">\(x,y\)</span> 的对换。假设 <spanclass="math inline">\(S=\{1,2,3,4\}\)</span>，我们可以用 <spanclass="math inline">\(f=(2,3)\)</span>来表示一个对换，它的涵义就等于<spanclass="math display">\[f=\begin{pmatrix}1&amp;2&amp;3&amp;4\\\downarrow&amp;\downarrow&amp;\downarrow&amp;\downarrow\\1&amp;3&amp;2&amp;4\end{pmatrix}\]</span></li><li>轮换，就是指几个元素轮流交换。形式化的，就是对于若干的元素<spanclass="math inline">\(x_1,x_2,\cdots,x_n\)</span>，<spanclass="math display">\[f(x)=\begin{cases}x_{i+1}&amp;{\rm if} \spacex=x_i,i\in[1,n-1]\\x_1 &amp;{\rm if}\space x=x_n \\x&amp;{\rm if}\spacex\not=x_i,u\in[1,n]\end{cases}\]</span>我们用 <spanclass="math inline">\(f=(x_1,x_2,\cdots,x_n)\)</span>来表示这个轮换。举个例子，假设 <spanclass="math inline">\(S=\{1,2,3,4\}\)</span>，<spanclass="math inline">\(f(1,3,4)\)</span> 就是指这个置换 <spanclass="math display">\[f=\begin{pmatrix}1&amp;2&amp;3&amp;4\\\downarrow&amp;\downarrow&amp;\downarrow&amp;\downarrow\\4&amp;2&amp;1&amp;3\end{pmatrix}\]</span>其中有一些结论并不是本文的重点，在下文会直接使用，建议先了解一下相关知识。</li></ul><h3 id="可解性判定">可解性判定</h3><p>我们先来讨论 <span class="math inline">\(4\times4\)</span>的情况。方便起见，我们将所有的空格都移动到右下角。我们将这十五的格子首尾相连，形成一排。将<span class="math inline">\(1\sim 15\)</span> 计入集合 <spanclass="math inline">\(S\)</span> 中。 我们定义 <spanclass="math inline">\(f(x,y)\)</span> 是将第 <spanclass="math inline">\(x\)</span> 个和第 <spanclass="math inline">\(y\)</span> 个进行交换，轮换也类似的定义。</p><h4 id="奇变换与偶变换">奇变换与偶变换</h4><p>我们建立一个初始状态（<span class="math inline">\(1\sim 15\)</span>排列好的情况）到现在状态的映射（空格也算进去，记作 <spanclass="math inline">\(0\)</span>）。我们发现这恰好是一个置换，我们求解这个问题其实就是就这个置换的逆。首先，恒同变换 <span class="math inline">\(\rm id\)</span>是偶变换。<br />考虑我们有什么操作可以进行，由于最终空格一定要回到原处，因此一来一回有两次路径，共有偶数次上下或左右对换，因此这个置换是偶置换就是可解的必要条件。但是开头的谜题指交换了<span class="math inline">\(14\)</span> 和 <spanclass="math inline">\(15\)</span>，是奇变换，因此不可解。但是偶置换是充分条件吗？</p><h4 id="轮换">轮换</h4><p>不同与前一章的建模方法，这次的映射不算空格，只有 <spanclass="math inline">\(15\)</span>个元素。我们来证明凡是偶置换都可以解。将这个置换记作 <spanclass="math inline">\(g\)</span>。由于空格始终都没有动，因此将空格去掉也是偶变换。</p><p>考虑在这个问题之中到底有什么操作可以进行。首先，对于这样的四个格子，可以让空格转一圈来使三个元素进行轮换。<spanclass="math display">\[\begin{array}{|c|c|}\hline 11&amp;12\\\hline 14&amp;\\\hline\end{array}\rightarrow \begin{array}{|c|c|}\hline 11&amp;\\\hline 14&amp;12\\\hline\end{array}\rightarrow \begin{array}{|c|c|}\hline &amp;11\\\hline 14&amp;12\\\hline\end{array}\rightarrow \begin{array}{|c|c|}\hline 14&amp;11\\\hline &amp;12\\\hline\end{array}\rightarrow \begin{array}{|c|c|}\hline 14&amp;11\\\hline 12&amp;\\\hline\end{array}\]</span>可以进行任意次轮换。</p><p>然后，我们可以通过将空格移到任意一个位置，在像上面一样进行轮换，接着原路返回，就可以在任意位置实现像这样的三轮换了。<spanclass="math display">\[\begin{array}{|c|c|c|c|}\hline 1&amp;2&amp;3&amp;4\\\hline 5&amp;6&amp;7&amp;8\\\hline 9&amp;10&amp;11&amp;12\\\hline 13&amp;15&amp;14&amp;\\\hline\end{array}\rightarrow\begin{array}{|c|c|c|c|}\hline 1&amp;2&amp;3&amp;4\\\hline 5&amp;6&amp;&amp;7\\\hline 9&amp;10&amp;11&amp;8\\\hline 13&amp;15&amp;14&amp;12\\\hline\end{array}\rightarrow\begin{array}{|c|c|c|c|}\hline 1&amp;6&amp;2&amp;4\\\hline 5&amp;3&amp;&amp;7\\\hline 9&amp;10&amp;11&amp;8\\\hline 13&amp;15&amp;14&amp;12\\\hline\end{array}\rightarrow\begin{array}{|c|c|c|c|}\hline 1&amp;6&amp;2&amp;4\\\hline 5&amp;3&amp;7&amp;8\\\hline 9&amp;10&amp;11&amp;12\\\hline 13&amp;15&amp;14&amp;\\\hline\end{array}\]</span>因此所有像这样的轮换都可以进行。</p><p>那么，我们只要使用轮换来实现对换的效果就可以了。实现的方法如下：</p><ul><li>对于四个不同的元素 <spanclass="math inline">\(a,b,c,d\)</span>，<spanclass="math inline">\((a,b)(c,d)=(a,b)(b,c)(b,c)(c,d)=(a,b,c)(b,c,d)\)</span><br /></li><li>对于三个不同的元素 <span class="math inline">\(a,b,c\)</span>，<spanclass="math inline">\((a,b)(b,c)=(a,b,c)\)</span><br />由于 <span class="math inline">\(g\)</span> 为偶，因此 <spanclass="math inline">\(g\)</span>的逆也为偶。因此，我们只要思考如何实现任何三个元素的轮换就可以了。</li></ul><p>这也是可以实现的。首先，我们需要了解置换对轮换的共轭是什么样的。假设<span class="math inline">\(g\)</span> 是置换。<spanclass="math display">\[g(x_1,\cdots,x_n)g^{-1}=(g(x_1),\cdots,g(x_n))\]</span>这是因为只有<span class="math inline">\(g^{-1}g(x_i)=x_i\)</span>，而 <spanclass="math inline">\(x_i\)</span> 会被轮换改变，因此只有 <spanclass="math inline">\(g(x_i)\)</span>这些元素会被轮换改变，其他的数并不会被轮换改变，之后进行的 <spanclass="math inline">\(g\)</span> 可以和 <spanclass="math inline">\(g^{-1}\)</span> 抵消，因此就相当于 <spanclass="math inline">\(g(x_i)\)</span>这些元素进行轮换。在这里不严格进行证明了，可以多模拟几遍感受一下。</p><p>我们先来讨论 <span class="math inline">\((i,12,15),i\in\{1,2,\cdots,11,13,14\}\)</span> （没有 <spanclass="math inline">\(12\)</span> 和 <spanclass="math inline">\(15\)</span>）这样的轮换。一定存在置换 <spanclass="math inline">\(f:S\mapsto S\)</span> 满足 <spanclass="math inline">\(f(11)=i,f(15)=15,f(12)=12\)</span>，其他元素我们不关心。此时<spanclass="math inline">\(f(11,12,15)f^{-1}=(f(11),f(12),f(15))=(i,12,15)\)</span></p><p>接下来考虑 <span class="math inline">\((i,j,15),i\not = j\space\text{AND}\space i,j=\in \{1,2,\cdots,11,13,14\}\)</span>。<spanclass="math display">\[\displaylines{(i,j,15) &amp;= (j,15,i)\\&amp;=(j,15)(15,12)(12,15)(15,i)\\&amp;=(j,15,12)(12,15,i)}\]</span>对于<span class="math inline">\((i,j,12)\)</span> 的情况同理。</p><p>最后，就是任意三个元素 <span class="math inline">\(i,j,k\)</span>的轮换 <span class="math inline">\((i,j,k)\)</span> 了。<spanclass="math display">\[\displaylines{(i,j,k)&amp;=(i,j)(j,k)\\&amp;=(i,j)(j,15)(15,j)(j,k)\\&amp;=(i,j,15)(15,j,k)}\]</span>至此，任何三轮换就都可以进行了。因此，偶置换总是可解的。</p><h3 id="扩展">扩展</h3><h4 id="ntimes-n"><span class="math inline">\(n\times n\)</span></h4><p>上面的两种方法很容易扩展到 <span class="math inline">\(n\timesn\)</span> 的情况。实际上，从 <spanclass="math inline">\(4\times4\)</span> 扩展到 <spanclass="math inline">\(n\times n\)</span> 只需要改变集合 <spanclass="math inline">\(S\)</span> 的大小和轮换部分的数值。集合 <spanclass="math inline">\(S\)</span>的大小实际与证明过程并无关系，因此只要将 <spanclass="math inline">\(12\)</span> 和 <spanclass="math inline">\(15\)</span> 替换成 <spanclass="math inline">\(n^2-n\)</span> 和 <spanclass="math inline">\(n^2-1\)</span> 即可。</p><h4 id="逆序对">逆序对</h4><p>考虑轮换方法。首先我们考虑只是用临项交换来将解决问题。所需要的置换次数其实就是序列的逆序对个数。由于这种只用临项交换的方法和其它使用对换的方法都是<span class="math inline">\(g\)</span>的逆，因此它们的奇偶性相同。所以一个状态是否可解就只需要看逆序对的奇偶性就可以了。</p><h4 id="空格">空格</h4><p>如果空格不在最右下角怎么办？考虑将空格移到右下角的过程。我们已经知道可解性和逆序对的关系了，因此我们只要注意逆序对个数就可以了。左右移动空格并不会改变逆序对个数，而像下移动空格会使逆序对发生变化。由于一个数和空格交换，到了<span class="math inline">\(n-1\)</span>个数之前。这就相当与这个数与前一个数交换 <spanclass="math inline">\(n-1\)</span>次的结果。因为每个数都各不相同，因此每次交换必定对逆序对产生 <spanclass="math inline">\(\pm1\)</span>的变化。由于我们只关心奇偶性，因此我们只关心这些 <spanclass="math inline">\(\pm1\)</span>加起来之后对奇偶性产生的影响，也就是模 <spanclass="math inline">\(2\)</span> 的结果。而 <spanclass="math inline">\(-1\equiv 1\pmod2\)</span>，所以它对逆序对奇偶性产生的影响就是 <spanclass="math inline">\((n-1)\times 1 \equiv n-1 \pmod 2\)</span>。</p><p>换句话将，这个操作对逆序对产生的影响和这 <spanclass="math inline">\(n-1\)</span> 个数的大小无关，只和 <spanclass="math inline">\(n-1\)</span>的奇偶性有关！因此，我们只要将原序列的逆序对个数求出，在加上需要移动的行数乘上<span class="math inline">\(n-1\)</span>，就可以进行判定了。</p><h4 id="任意两个状态是否可达">任意两个状态是否可达</h4><p>实际上，通过上面两种方法我们可以了解到，任意两个状态分别记作 <spanclass="math inline">\(f,g\)</span>，只要可以通过偶数次对换相互抵达，那么这两个状态在奇数码问题中就可以相互抵达。当然，需要先将空格移动到最右下角。当然，由于两个状态都需要加上行数乘上<span class="math inline">\(n-1\)</span>，我们只需要计算行数差在乘上<span class="math inline">\(n-1\)</span> 就可以得到影响了。</p><h4 id="ntimes-m"><span class="math inline">\(n\times m\)</span></h4><p>这个问题的推广实际上也不是很难，只需要将上面两个问题的 <spanclass="math inline">\(n-1\)</span> 替换位 <spanclass="math inline">\(m-1\)</span> 即可，因为只有这两项和列数有关。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>城市游戏题解</title>
    <link href="/posts/44897/"/>
    <url>/posts/44897/</url>
    
    <content type="html"><![CDATA[<p>模仿直方图中最大的矩形的求法，把地图分行处理，将下一行看作是累加再上一行后面的矩形，当出现R时我们认为矩形缺了一块。</p><p>先考虑题目的一种简单情况：两边矩形的边界都在扩大，如图所示<br /><img src="/img/Pasted%20image%2020240413123538.png" /></p><p>那么要求出其中最大矩形的面积，我们可以考虑将每个矩形的高度作为结果矩形的高，宽度延展到右边界得到的面积。再这个例子中，就是这几个矩形中的最大值<br /><img src="/img/Pasted%20image%2020240413123741.png" /> <imgsrc="/img/Pasted%20image%2020240413123822.png" /> <imgsrc="/img/Pasted%20image%2020240413123843.png" /> <imgsrc="/img/Pasted%20image%2020240413123910.png" /> <imgsrc="/img/Pasted%20image%2020240413123931.png" />此时考虑左侧有分叉的情况，比如：<br /><img src="/img/Pasted%20image%2020240413124127.png" />此时，再考虑有分叉的行的时候，只要考虑矩形分成各个小段后，各个小段的高度作为矩形的高度，宽度延展到右边界的矩形中最大的一个最大值即可。例如再考虑第4列时，应该考虑这两个矩形面积的最大值。<br /><img src="/img/Pasted%20image%2020240413152545.png" />注意到宽度一定，所以高度高的面积就大。注意到这两种情况都有一个共同点，就是后面的矩形都可以覆盖前面的矩形。因此，我们可以维护一个具有这样性质的单调栈。</p><p>接下来考虑插入的情况。</p><ol type="1"><li>如果新插入的矩形不会改变单调性，直接插入。</li><li>如果新插入的矩形会改变单调性，那么持续弹出栈顶，依次考虑每个矩形，更新最大值。注意到再这样考虑完之后，只有可以与新插入的矩型会参与后面的计算，其余部分则是无用的，因此我们用这个矩形来替代原矩形。比如这张图中红色部分则是无用的。<br /><img src="/img/Pasted%20image%2020240413153959.png" />注意，由于每个矩形的形状不同，因此最后保留的部分也不一定相同，再弹出时要比较与上一个矩形是否完全一样，如果是再累加长度，否则新开一个矩形。比如下图中黄色和蓝色两个矩形都是被保留下来的，但是形状不一样。<br /><img src="/img/Pasted%20image%2020240413154349.png" /></li></ol><p>我们可以用一个二进制整数来存储矩形的长度（1代表F，0代表R），用按位或运算来检验是否可以完全覆盖，用按位与得到保留下来的矩形，扫描最长的连续1的长度得到高度。考虑到答案范围较大，因此可以使用<code>std::bitset</code>来存储。</p><p>这个算法的复杂度是：单调栈 <spanclass="math inline">\(\operatorname{O}(n)\)</span>，扫描得到最大连续一的长度<spanclass="math inline">\(\operatorname{O}(m)\)</span>，由于每次更新都要扫描，因此总复杂度是<span class="math inline">\(\operatorname{O}(nm)\)</span>。</p><p>参考代码：（由于代码中大量使用stl，常数较大，因此手动开启O2优化。复杂度是正确的）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    bitset&lt;1005&gt; b;<br>    <span class="hljs-type">int</span> width;<br>    <span class="hljs-type">int</span> maxl;<br>&#125;;<br><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max_lenth</span><span class="hljs-params">(<span class="hljs-type">const</span> bitset&lt;<span class="hljs-number">1005</span>&gt;&amp; b)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">if</span>(b[i<span class="hljs-number">+1</span>]==<span class="hljs-number">1</span>)&#123;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans=<span class="hljs-built_in">max</span>(ans,res);<br>            res=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    ans=<span class="hljs-built_in">max</span>(ans,res);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    stack&lt;node&gt; s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        bitset&lt;1005&gt; bi;<br>        stack&lt;node&gt; temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++,bi&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">char</span> x;<br>            cin&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>                bi^=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        temp.<span class="hljs-built_in">push</span>(&#123;bi,<span class="hljs-number">1</span>,<span class="hljs-built_in">max_lenth</span>(bi)&#125;);<br>        <span class="hljs-type">int</span> width=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;(bi|s.<span class="hljs-built_in">top</span>().b)!=bi)&#123;<br>            width+=s.<span class="hljs-built_in">top</span>().width;<br>            <span class="hljs-keyword">if</span>((bi&amp;s.<span class="hljs-built_in">top</span>().b)==temp.<span class="hljs-built_in">top</span>().b)&#123;<br>                <span class="hljs-keyword">auto</span> x=temp.<span class="hljs-built_in">top</span>();<br>                temp.<span class="hljs-built_in">pop</span>();<br>                x.width+=s.<span class="hljs-built_in">top</span>().width;<br>                temp.<span class="hljs-built_in">push</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>            temp.<span class="hljs-built_in">push</span>(&#123;(bi&amp;s.<span class="hljs-built_in">top</span>().b),s.<span class="hljs-built_in">top</span>().width,<span class="hljs-built_in">max_lenth</span>(bi&amp;s.<span class="hljs-built_in">top</span>().b)&#125;);<br>            &#125;<br>            ans=<span class="hljs-built_in">max</span>(ans,s.<span class="hljs-built_in">top</span>().maxl*width);<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!temp.<span class="hljs-built_in">empty</span>())&#123;<br>            s.<span class="hljs-built_in">push</span>(temp.<span class="hljs-built_in">top</span>());<br>            temp.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br>        w+=s.<span class="hljs-built_in">top</span>().width;<br>        ans=<span class="hljs-built_in">max</span>(ans,s.<span class="hljs-built_in">top</span>().maxl*w);<br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout&lt;&lt;ans*<span class="hljs-number">3</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复数和平面几何</title>
    <link href="/posts/60112/"/>
    <url>/posts/60112/</url>
    
    <content type="html"><![CDATA[<p>众所周知，在实数域上我们时不能随意开方的，因为没有数的平方为负。为了解决这个问题，我们定义一个新数，<spanclass="math inline">\(\rm{i}\)</span>。我们定义<spanclass="math display">\[\rm{i}^2=-1\]</span>定义复数 <spanclass="math inline">\(x\in \mathbb{C}\)</span> 是形如 <spanclass="math inline">\(a+b\rm{i}\)</span> 的数。</p><p>接下来定义各种运算符：</p><ol type="1"><li>加法：<spanclass="math inline">\((a+b\rm{i})+(c+d\rm{i})=(a+c)+(b+d)\rm{i}\)</span></li><li>乘法：<spanclass="math inline">\((a+b\rm{i})(c+d\rm{i})=ac+ad\rm{i}+bc\rm{i}-bd=(ac-bd)+(ad+bc)\rm{i}\)</span></li><li>相反数：<spanclass="math inline">\(-(a+b\rm{i})=(-a)+(-b)\rm{i}\)</span></li><li>倒数：<spanclass="math inline">\((a+b\rm{i})^{-1}=\dfrac{1}{a+b\rm{i}}\)</span>这一点十分有趣，到底结果是多少呢？我们假设 <spanclass="math inline">\((a+b\rm{i})^{-1}=c+d\rm{i}\)</span>，然后可以得到<spanclass="math display">\[\displaylines{&amp;(a+b\rm{i})^{-1}=c+d\rm{i}\\\Rightarrow&amp;(a+b\rm{i})(c+d\rm{i})=1\\ \Rightarrow&amp;(ac-bd)+(ad+bc)\rm{i}=1\\ \Rightarrow &amp;\begin{cases}ac-bd=1\\ad+bc=0\end{cases}\\ \Rightarrow &amp;\begin{cases}c=\dfrac{a}{a^2+b^2}\\d=-\dfrac{b}{a^2+b^2}\end{cases}(a\not=0,b\not=0)}\]</span></li></ol><h2 id="模型1向量">模型1：向量</h2><p>我们将 <span class="math inline">\((a,b)\)</span>当作平面上的一个向量，我们惊人的发现：负数加法就是向量加法，而负数乘法，可以定义一种叫复乘的运算，定义两个向量<span class="math inline">\(\begin{bmatrix}a\\b \end{bmatrix} \times\begin{bmatrix}c\\d \end{bmatrix}=\begin{bmatrix}ac-bd\\ ad+bc\end{bmatrix}\)</span>，这样，我们就可以将复数当作向量来计算了。</p><p>有趣的是，两个向量进行复乘，结果恰好等于两个向量长度相乘，与 <spanclass="math inline">\(x\)</span>轴正半轴的逆时针夹角相加得到的向量。感兴趣可以自己算一下，我们稍后会给出证明。</p><h2 id="模型2映射">模型2：映射</h2><p>虽然 <span class="math inline">\(x^2=-1\)</span>在实数与上没有解，但是我们能不能找到一种映射 <spanclass="math inline">\(J:\mathbb{R}^2\mapsto \mathbb{R}^2\)</span>，使得<span class="math inline">\(J^2=-id\)</span>？显然是有的，逆时针旋转<span class="math inline">\(90^\circ\)</span> 就是其中一个。此时 <spanclass="math inline">\(J\)</span> 是线性变换，矩阵为 <spanclass="math inline">\(\begin{bmatrix}0&amp;-1\\1&amp;0\end{bmatrix}\)</span>。此时，我们自然可以把这个<span class="math inline">\(J\)</span> 对应到 <spanclass="math inline">\(\rm{i}\)</span>，把复数 <spanclass="math inline">\(a+b\rm{i}\)</span> 同样当作映射，写成 <spanclass="math inline">\(a\times id+b\times J\)</span>的形式，最后的变换矩阵为 <spanclass="math inline">\(\begin{bmatrix}a&amp;-b\\b&amp;a\end{bmatrix}\)</span>。</p><p>我们再次惊人的发现：复数相加知道把对应的矩阵相加就可以得到结果的矩阵，复数相乘只要把对应的矩阵相乘即可，实际上对应了映射的复合（而且满足交换律）。</p><p>我们将最终的矩阵提取出来一个 <spanclass="math inline">\(\sqrt{a^2+b^2}\)</span>，将原来的矩阵写成 <spanclass="math inline">\(\sqrt{a^2+b^2}\begin{bmatrix}\dfrac{a}{\sqrt{a^2+b^2}}&amp;-\dfrac{b}{\sqrt{a^2+b^2}}\\ \dfrac{b}{\sqrt{a^2+b^2}}&amp;\dfrac{a}{\sqrt{a^2+b^2}} \end{bmatrix}\)</span> 的形式，发现 <spanclass="math inline">\((\dfrac{a}{\sqrt{a^2+b^2}})^2+(\dfrac{b}{\sqrt{a^2+b^2}})^2=1\)</span>，因此原来的矩阵实际上就是一个旋转变换复合上一个放缩变换，放缩的大小恰好就是<spanclass="math inline">\(\sqrt{a^2+b^2}\)</span>（即两个基向量的长度）。</p><p>此时进行复乘，实际上就是将放缩的长度相乘，将旋转的角度相加。</p><h2 id="映射和向量">映射和向量</h2><p>从模型1可以知道，<span class="math inline">\(\mathbb{R}^2\)</span>上的一个元素恰好对应了一个 <spanclass="math inline">\(\mathbb{C}\)</span> 中的元素。我们从中取出一个元素<span class="math inline">\(\begin{bmatrix}a\\b\end{bmatrix}\)</span>，将 <spanclass="math inline">\(\begin{bmatrix}a\\b \end{bmatrix}\)</span> 和<span class="math inline">\(\begin{bmatrix}c\\ d \end{bmatrix}\)</span>进行复乘，得到 <span class="math inline">\(\begin{bmatrix}ac-bd\\ ad+bc\end{bmatrix}\)</span>。有趣的是，将 <spanclass="math inline">\(\begin{bmatrix}c\\ d \end{bmatrix}\)</span> 应用<span class="math inline">\(\begin{bmatrix}a\\b \end{bmatrix}\)</span>所对应的 <span class="math inline">\(\begin{bmatrix}a&amp; -b \\ b&amp;a \end{bmatrix}\)</span> 变换，同样可以得到 <spanclass="math inline">\(\begin{bmatrix}ac-bd\\ ad+bc\end{bmatrix}\)</span>。因此，两个模型是可以混用的。实际上，我们可以通过在模型二的算式后乘上一个单位向量<spanclass="math inline">\(\begin{bmatrix}1\\0\end{bmatrix}\)</span>，就可以将矩阵转化成同一个复数对应的向量，就可以得到这个结论（由于矩阵乘法满足结合律，所以先复合和先转化为向量没有区别，最后结果是一样的）。因此，复乘其实就是在应用变换，这样，，就不难解释复乘长度相乘，角度相加的现象了。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从1到有理数</title>
    <link href="/posts/34037/"/>
    <url>/posts/34037/</url>
    
    <content type="html"><![CDATA[<blockquote><p>数学有趣的一点在于，有些概念总是在应用之后再定义。 ——沃兹基硕德</p></blockquote><p>今天，我们将要再这里，定义数学中最基础的概念，数字！</p><h3 id="正整数集合">正整数集合</h3><p>一切的一切，都从<span class="math inline">\(1\)</span>开始： <spanclass="math display">\[\left\{1\right\}\]</span></p><h4 id="后继运算">后继运算</h4><p>接下来，我们定义一个运算符：后继运算符。顾名思义，就是指后面的那个数。下文将<span class="math inline">\(x\)</span> 的后继数记作 <spanclass="math inline">\(\operatorname{s}(x)\)</span>。（鉴于这是篇关于数学的文章，就不用<span class="math inline">\(x++\)</span> 之类的表达方式了）。</p><p>这个运算有一下几条性质:</p><ol type="1"><li><p><span class="math inline">\(1\)</span>不是任何数的后继数。</p></li><li><p>任何不是 <span class="math inline">\(1\)</span>的数都是一个数的后继数。</p></li><li><p>如果两数后继数相等，则这两个数相等。 这样，我们就可以定义 <spanclass="math inline">\(\mathbb{N}_1\)</span>。</p></li><li><p><span class="math inline">\(1\in\mathbb{N}_1\)</span></p></li><li><p>如果 <span class="math inline">\(x\in\mathbb{N}_1\)</span>，那么<spanclass="math inline">\(\operatorname{s}(x)\in\mathbb{N}_1\)</span>。</p></li></ol><p>之后，我们给予 <span class="math inline">\(1\)</span>的后继数一个符号 <span class="math inline">\(2\)</span>，<spanclass="math inline">\(2\)</span> 的后继数一个符号 <spanclass="math inline">\(3\)</span>，依次类推，就有了我们现在所说的正整数。这实际上就是我们常说的皮亚诺算数公理。</p><h4 id="数学归纳法">数学归纳法</h4><p>在 <span class="math inline">\(\mathbb{N}_1\)</span>中，数学归纳法是成立的。数学归纳法是指对于任何一个命题 <spanclass="math inline">\(\operatorname{P}(x)\)</span>，如果可以证明 <spanclass="math inline">\(\operatorname{P}(1)\)</span> 成立，并且可以证明<spanclass="math inline">\(\operatorname{P}(n)\Rightarrow\operatorname{P}(s(n))\)</span>，就可以证明<span class="math inline">\(\operatorname{P}(x)\)</span> 对全体 <spanclass="math inline">\(x\in \mathbb{N}_1\)</span> 成立。即 <spanclass="math display">\[\left. \begin{array}\operatorname{P}(1)\\\operatorname{P}(x)\Rightarrow\operatorname{P}(\operatorname{s}(x))\end{array} \right\}\Rightarrow \forall x\in\mathbb{N}_1,\operatorname{P}(x)\]</span> 乍一看，数学归纳法似乎很符合直觉，这样似乎总是正确的，因为<span class="math inline">\(\operatorname{P}(1)\)</span> 可以推出 <spanclass="math inline">\(\operatorname{P}(2)\)</span> 成立，<spanclass="math inline">\(\operatorname{P}(2)\)</span> 又可以推出 <spanclass="math inline">\(\operatorname{P}(3)\)</span>成立……这样一直进行下去，总有一步可以推出 <spanclass="math inline">\(\forallx\in\mathbb{N}_1,\operatorname{P}(x)\)</span> 成立（显然 <spanclass="math inline">\(x\)</span>是有限的，因此论证总可以在有限步之内完成）。然而，数学归纳法也可以推导出了哥德尔不完备定理，从而证明包含皮亚诺算数公理体系的数学不具有完备性。</p><h4 id="其它运算符">其它运算符</h4><p>接下来，就是定义其他运算：</p><ol type="1"><li>加法 <span class="math inline">\(\mathbb{N}_1\)</span>上的加法运算有两条法则：<ol type="1"><li><span class="math inline">\(a+1=\operatorname{s}(a)\)</span></li><li><spanclass="math inline">\(a+\operatorname{s}(b)=\operatorname{s}(a+b)\)</span>。这样定义加法是可以保证最终可以运算出结果的，因为可以用第二条法则不断减少<span class="math inline">\(b\)</span> 直到 <spanclass="math inline">\(b=1\)</span>，此时再用第一条法则就可以算出结果</li></ol></li><li>乘法 <span class="math inline">\(\mathbb{N}_1\)</span>上的乘法运算同样有两条法则：<ol type="1"><li><span class="math inline">\(a\times1=a\)</span></li><li><span class="math inline">\(a\times\operatorname{s}(b)=ab+a\)</span>和加法类似，这样定义乘法可以保证任意两个 <spanclass="math inline">\(\mathbb{N}_1\)</span>中的数相乘都可以算出结果。</li></ol></li></ol><p>以及证明各种运算律：</p><ol type="1"><li><p>（加法交换律）<span class="math inline">\(a+b=b+a\)</span>首先，我们先证明 <spanclass="math inline">\(\operatorname{s}(a)+b=\operatorname{s}(a+b)\)</span>。当 <span class="math inline">\(b=1\)</span> 时，<spanclass="math display">\[\displaylines{\operatorname{s}(a)+1=\operatorname{s}(\operatorname{s}(a))\\\operatorname{s}(a+1)=\operatorname{s}(\operatorname{s}(a))}\]</span>所以当 <span class="math inline">\(b=1\)</span> 时有 <spanclass="math inline">\(\operatorname{s}(a)+b=\operatorname{s}(a+b)\)</span>。假设当 <span class="math inline">\(b=n\)</span> 时 <spanclass="math inline">\(\operatorname{s}(a)+b=\operatorname{s}(a+b)\)</span>，那么当<span class="math inline">\(b=\operatorname{s}(n)\)</span> 时<spanclass="math display">\[\displaylines{\operatorname{s}(a)+b=\operatorname{s}(a)+\operatorname{s}(n)=\operatorname{s}(\operatorname{s}(a)+n)=\operatorname{s}(\operatorname{s}(a+n))\\\operatorname{s}(a+b)=\operatorname{s}(a+\operatorname{s}(n))=\operatorname{s}(\operatorname{s}(a+n))}\]</span>所以也有 <spanclass="math inline">\(\operatorname{s}(a)+b=\operatorname{s}(a+b)\Rightarrow\operatorname{s}(a)+\operatorname{s}(b)=\operatorname{s}(a+\operatorname{s}(b))\)</span>。再由数学归纳法可知<spanclass="math display">\[\operatorname{s}(a)+b=\operatorname{s}(a+b)\]</span>接下来开始证明加法交换律。</p><p>先证明 <span class="math inline">\(a+1=1+a\)</span>（即当 <spanclass="math inline">\(b=1\)</span>时的情况），仍然利用数学归纳法证明。</p><p>当 <span class="math inline">\(a=1\)</span> 时，<spanclass="math inline">\(a+1=1+a=2\)</span>。 当 <spanclass="math inline">\(a=n\)</span> 时有 <spanclass="math inline">\(a+1=1+a\)</span>，则当 <spanclass="math inline">\(a=\operatorname{s}(n)\)</span> 时有<spanclass="math display">\[a+1=\operatorname{s}(n)+1=\operatorname{s}(n+1)=\operatorname{s}(1+n)=1+\operatorname{s}(n)=1+a\]</span>再由数学归纳法可知原命题成立。接下来假设 <span class="math inline">\(b=n\)</span> 时有 <spanclass="math inline">\(a+b=b+a\)</span>，则当 <spanclass="math inline">\(b=\operatorname{s}(n)\)</span> 时 <spanclass="math display">\[a+b=a+\operatorname{s}(n)=\operatorname{s}(a+n)=\operatorname{s}(n+a)=\operatorname{s}(n)+a=b+a\]</span>在用数学归纳法可以得知加法交换律成立。</p></li><li><p>（乘法交换律）<span class="math inline">\(a\times b=b\timesa\)</span> 和加法交换律类似，先用数学归纳法证明 <spanclass="math inline">\(a\times1=1\times a\)</span>，再用一次数学归纳法证<span class="math inline">\(a\times b=b\times a\)</span>。 当 <spanclass="math inline">\(a=1\)</span> 时，<spanclass="math inline">\(a\times 1=1\times a=1\)</span>。 当 <spanclass="math inline">\(a=n\)</span> 时有 <spanclass="math inline">\(a\times 1=1\times a\)</span>，则当 <spanclass="math inline">\(a=\operatorname{s}(n)\)</span> 时有<spanclass="math display">\[a\times 1=\operatorname{s}(n)\times1=\operatorname{s}(n)=n+1=1\times n+1=1\times\operatorname{s}(n)=1\times a\]</span>再由数学归纳法可知原命题成立。</p><p>接下来证明 <span class="math inline">\(\operatorname{s}(a)\timesb=ab+b\)</span>。 当 <span class="math inline">\(b=1\)</span> 时有 <spanclass="math inline">\(\operatorname{s}(a)\timesb=\operatorname{s}(a)=a+1=ab+b\)</span>。 当 <spanclass="math inline">\(b=n\)</span> 时 <spanclass="math inline">\(\operatorname{s}(a)\times b=ab+b\)</span>，那么当<span class="math inline">\(b=\operatorname{s}(n)\)</span> 时 <spanclass="math display">\[\displaylines{\operatorname{s}(a)\timesb=\operatorname{s}(a)\times\operatorname{s}(n)=\operatorname{s}(a)\timesn+\operatorname{s}(a)=an+n+a+1\\ab+b=a\times\operatorname{s}(n)+\operatorname{s}(n)=an+a+n+1=an+n+a+1}\]</span>证明完毕。</p><p>接下来假设 <span class="math inline">\(b=n\)</span> 时有 <spanclass="math inline">\(a\times b=b\times a\)</span>，则当 <spanclass="math inline">\(b=\operatorname{s}(n)\)</span> 时<spanclass="math display">\[a\times b=a\times\operatorname{s}(n)=an+a=na+a=\operatorname{s}(n)\times a=b\timesa\]</span>在用数学归纳法可以得知乘法交换律成立。</p></li><li><p>（乘法分配律）<spanclass="math inline">\(a\times(b+c)=ac+bc\)</span> 证明：当 <spanclass="math inline">\(c=1\)</span> 时，有 <spanclass="math display">\[a\times(b+c)=a\times\operatorname{s}(b)=ab+a=ab+ac\]</span>当<span class="math inline">\(c=n\)</span> 时，<spanclass="math inline">\(a\times(b+c)=ac+bc\)</span>，当 <spanclass="math inline">\(c=\operatorname{s}(n)\)</span> 时 <spanclass="math display">\[\displaylines{a\times(b+c)=a\times[b+\operatorname{s}(n)]\\=a\times\operatorname{s}(b+n)=a\times(b+n)+a\\=ab+an+a\\=ab+a\times\operatorname{s}(n)\\=ab+ac}\]</span>用数学归纳法得知原命题成立。</p></li><li><p>（加法结合律）<spanclass="math inline">\((a+b)+c=a+(b+c)\)</span>这次不用用数学归纳法了，太好了。 当 <spanclass="math inline">\(b=1\)</span> 时，<spanclass="math display">\[\displaylines{(a+b)+c=\operatorname{s}(a)+c=\operatorname{s}(a+c)\\a+(b+c)=a+\operatorname{s}(c)=\operatorname{s}(a+c)}\]</span>当 <spanclass="math inline">\(b\not = 1\)</span> 时，设 <spanclass="math inline">\(b=\operatorname{s}(p)\)</span>，<spanclass="math display">\[\displaylines{(a+b)+c=[a+\operatorname{s}(p)]+c=\operatorname{s}(a+p)+c=\operatorname{s}(a+p+c)\\a+(b+c)=a+[\operatorname{s}(p)+c]=a+\operatorname{s}(p+c)=\operatorname{s}(a+p+c)}\]</span>所以原命题成立。</p></li><li><p>（乘法结合律）<span class="math inline">\((a\times b)\timesc=a\times (b\times c)\)</span> 当 <spanclass="math inline">\(b=1\)</span> 时，<spanclass="math display">\[\displaylines{(a\times b)\times c=a\times c\\a\times(b\times c)=a\times c}\]</span>当 <spanclass="math inline">\(b\not = 1\)</span> 时，依然设 <spanclass="math inline">\(b=\operatorname{s}(p)\)</span>，<spanclass="math display">\[\displaylines{(a\times b)\timesc=[a\times\operatorname{s}(p)]\times c=(ap+a)\timesc=acp+ac\\a\times(b\times c)=a\times[\operatorname{s}(p)\timesc]=a\times(pc+c)=acp+ac}\]</span>所以原命题成立。</p></li></ol><h4 id="序关系">序关系</h4><p>我们定义 <span class="math inline">\(\mathbb{N}_1\)</span>上的一个序关系，记作 <span class="math inline">\(\lt\)</span>。我们定义<span class="math inline">\(a\lt b\)</span> 当且仅当存在 <spanclass="math inline">\(c\)</span>，使 <spanclass="math inline">\(a+c=b\)</span>。</p><h5 id="性质">性质</h5><ol type="1"><li>（<span class="math inline">\(\lt\)</span> 是严格序）<spanclass="math inline">\(a\not\lt a,a\lt b,b\lt c\Rightarrow a\ltc\)</span> 因为对于任意 <span class="math inline">\(x\)</span>，<spanclass="math inline">\(a+x=a+x\)</span>，所以 <spanclass="math inline">\(a\lt a+x\)</span>，因此 <spanclass="math inline">\(a\not\lt a\)</span>。假设 <spanclass="math inline">\(a+m=b,b+n=c\)</span>，那么 <spanclass="math inline">\(a+n+m=c\)</span>，所以 <spanclass="math inline">\(a\lt c\)</span>。</li><li><span class="math inline">\(a\lt b\Rightarrow\begin{cases}a+c\ltb+c\\ ac\lt bc \end{cases}\)</span> 证明：假设 <spanclass="math inline">\(a+p=b\)</span>，那么 <spanclass="math inline">\(a+p+c=b+c\)</span>，<spanclass="math inline">\(ac+pc=(a+p)c=bc\)</span>。</li><li>（最小数原理）在 <span class="math inline">\(\mathbb{N}_1\)</span>的非空子集中，必有最小元。</li></ol><h3 id="自然数集合">自然数集合</h3><p>在 <span class="math inline">\(\mathbb{N}_1\)</span>的基础上增加一个元素 <span class="math inline">\(0\)</span>，令 <spanclass="math inline">\(\operatorname{s}(0)=1\)</span>。我们为零专门加一些补丁来保证<span class="math inline">\(\mathbb{N}_0\)</span>上的加乘运算是可以进行的。<spanclass="math display">\[\displaylines{0\lt 1,0\lt x(x\in \mathbb{N}_1)\\0+x=x+0=x\\0\timesx=x\times0=0}\]</span>容易证明，正整数集合上的各种运算律，最小数原理在<span class="math inline">\(\mathbb{N}_0\)</span> 上仍然成立。</p><h4 id="和-1"><span class="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span></h4><p>那么，究竟什么是 <span class="math inline">\(0\)</span>，<spanclass="math inline">\(1\)</span>呢？有个非常有趣的说法，叫做万物都是有结构的空。我们可以这样定义 <spanclass="math inline">\(0\)</span>。<spanclass="math display">\[0=\emptyset\]</span>接着这么定义 <spanclass="math inline">\(\operatorname{s}(x)\)</span><spanclass="math display">\[\operatorname{s}(x)=\{x,\emptyset\}\]</span>举个例子，<spanclass="math inline">\(\operatorname{s}(0)=1\)</span>，所以<spanclass="math inline">\(1=\{0,\emptyset\}\)</span>，由于两个元素重复了，所以 <spanclass="math inline">\(1=\{\emptyset\}\)</span>。之后就是 <spanclass="math inline">\(\operatorname{s}(1)=2\)</span>，那么 <spanclass="math inline">\(2=\{ 1,\emptyset\}=\{\{\emptyset\},\emptyset\}\)</span>。看，万物果然是有结构的空。</p><h3 id="整数集合">整数集合</h3><p>由于在 <span class="math inline">\(\mathbb{N}\)</span>上的一些加法方程无解，而且不能任意做差。因此，我们引入一个新的集合，整数集合<span class="math inline">\(\mathbb{Z}\)</span>。</p><p>先定义 <spanclass="math inline">\(\mathop{\mathbb{Z}}\limits^{\sim}=\mathbb{N}_1\times\mathbb{N}_0\)</span>。也就是说，<spanclass="math inline">\(\mathop{\mathbb{Z}}\limits^{\sim}\)</span>中的每个元素都是由一个正整数和一个自然数组成的数对。我们将这样一个元素记作<spanclass="math inline">\((a,b),a\in\mathbb{N}_1,b\in\mathbb{N}_0\)</span>。接下来定义等价运算<span class="math inline">\(=\)</span>。我们说 <spanclass="math inline">\((a,b)=(a^\prime,b^\prime)\)</span> 当且仅当 <spanclass="math inline">\(a+b^\prime=a^\prime+b\)</span>。</p><p>（传递性）如果 <spanclass="math inline">\((a,b)=(a^\prime,b^\prime),(a^\prime,b^\prime)=(a^{\prime\prime},b^{\prime\prime})\)</span>，那么<spanclass="math inline">\((a,b)=(a^{\prime\prime},b^{\prime\prime})\)</span>。从前两个条件可以看出，<spanclass="math inline">\(a+b^\prime=a^\prime+b,a^\prime+b^{\prime\prime}=a^{\prime\prime}+b^\prime\)</span>，两式相加得<spanclass="math inline">\(a+b^\prime+a^\prime+b^{\prime\prime}=a^\prime+b+a^{\prime\prime}+b^\prime\)</span>，消去<span class="math inline">\(a^\prime+b^\prime\)</span> 得 <spanclass="math inline">\(a+b^{\prime\prime}=a^{\prime\prime}+b\)</span>，原命题得证。我们将所有重复的元素从<span class="math inline">\(\mathop{\mathbb{Z}}\limits^\sim\)</span>中减去得到 <span class="math inline">\(\mathbb{Z}\)</span>。</p><p>接下来定义 <span class="math inline">\(\mathbb{Z}\)</span>上的各种运算。</p><ol type="1"><li>加法：<spanclass="math inline">\((a,b)+(c,d)=(a+c,b+d)\)</span>。</li><li>乘法：<spanclass="math inline">\((a,b)\times(c,d)=(ac+bd,ad+bc)\)</span></li><li>相反数：<span class="math inline">\(-(a,b)=(b,a)\)</span></li></ol><p>之后，我们需要证明这些运算的结果和代表元无关。就是换一个和其中一个元素等价的数，结果是否和原来一样。以加法为例。假设<spanclass="math inline">\((a,b)=(a^\prime,b^\prime)\)</span>，那么<spanclass="math display">\[\displaylines{(a,b)+(c,d)=(a+c,b+d)\\(a^\prime,b^\prime)+(c,d)=(a^\prime+c,b^\prime+d)}\]</span>此时<spanclass="math display">\[\displaylines{a+c+b^\prime+d=a+b^\prime+c+d\\b+d+a^\prime+c=a^\prime+b+c+d}\]</span>所以 <spanclass="math inline">\((a+c,b+d)=(a^\prime+c,b^\prime+d)\)</span>。</p><p>接下来是乘法： <spanclass="math display">\[\displaylines{(a,b)\times(c,d)=(ac+bd,ad+bc)\\(a^\prime,b^\prime)\times(c,d)=(a^\prime c+b^\prime d,a^\primed+b^\prime c)}\]</span>此时<spanclass="math display">\[\displaylines{ad+bc+a^\prime c+b^\primed=(a^\prime+b)c+(a+b ^\prime)d\\ ac+bd+a^\prime d+b^\primec=(a+b^\prime)c+(a^\prime+b)d}\]</span>所以是等价的。</p><p>还有相反数： <spanclass="math display">\[\displaylines{-(a,b)=(b,a)\\-(a^\prime,b^\prime)=(b^\prime,a^\prime)}\]</span>显然<spanclass="math inline">\(a+b^\prime=a^\prime+b\)</span>，结果等价。</p><p><span class="math inline">\(\mathbb{Z}\)</span>上的各种运算律都是直接运算再用 <spanclass="math inline">\(\mathbb{N}\)</span>上的运算量就可以证明了，这里不过多赘述。</p><p><span class="math inline">\(\mathbb{Z}\)</span>还有一个有趣的性质，<spanclass="math inline">\((\mathbb{Z},0,+,-)\)</span> 是交换群。这意味着</p><ol type="1"><li>加法交换律和加法结合律成立</li><li><span class="math inline">\(x+0=0+x\)</span></li><li><span class="math inline">\(x+(-x)=(-x)+x=0\)</span></li></ol><p>这些刚刚都证明过了。此时，我们称 <spanclass="math inline">\(0\)</span> 为单位元或恒等元。</p><p>同时，<span class="math inline">\(\mathbb{Z}\)</span>是一个整环。这意味着</p><ol type="1"><li>乘法交换律，结合律，分配律成立。</li><li><span class="math inline">\(1\times x=x\times 1\)</span></li><li>没有零因子：<span class="math inline">\(x,y\not = 0\Rightarrowxy\not=0\)</span>，<span class="math inline">\(xy=0\Rightarrow x=0\lory=0\)</span></li></ol><p>此时称 <span class="math inline">\(1\)</span> 为乘法单位元。</p><p>此外，<span class="math inline">\(\mathbb{Z}\)</span>还是一个欧式环，因为 <span class="math inline">\(\mathbb{Z}\)</span>中有除法原理。</p><h3 id="有理数">有理数</h3><p>和整数类似，我们仍先定义 <spanclass="math inline">\(\mathop{\mathbb{Q}}\limits^\sim=\mathbb{Z}\times\mathbb{Z}^*\)</span>（<spanclass="math inline">\(\mathbb{Z}^*=\mathbb{Z}-\{0\}\)</span>），将其中的一个元素记为<spanclass="math inline">\((a,b),a\in\mathbb{Z},b\in\mathbb{Z}^*\)</span>，我们给这个元素一个符号<span class="math inline">\(\dfrac{a}{b}\)</span>。接着定义 <spanclass="math inline">\(\mathbb{Q}\)</span> 中的等价关系：<spanclass="math inline">\((a,b)=(c,d)\)</span> 当且仅当 <spanclass="math inline">\(ad=bc\)</span>。</p><p>类似的，将 <span class="math inline">\(\mathbb{Z}\)</span> 嵌入 <spanclass="math inline">\(\mathbb{Q}\)</span>：<spanclass="math inline">\(a\in\mathbb{Z},a\rightarrow\dfrac{a}{1}\)</span>。</p><p>定义加法，乘法：</p><ol type="1"><li><spanclass="math inline">\(\dfrac{a}{b}\times\dfrac{c}{d}=\dfrac{ac}{bd}\)</span></li><li><spanclass="math inline">\(\dfrac{a}{b}+\dfrac{c}{d}=\dfrac{ad+bc}{bd}\)</span></li><li><span class="math inline">\(\forall x\in\mathbb{Q}^*,\existsy,xy=1\)</span>，此时称 <span class="math inline">\(y\)</span> 为 <spanclass="math inline">\(x\)</span> 的倒数，记作 <spanclass="math inline">\(y=x^{-1}\)</span>，假设 <spanclass="math inline">\(x=\dfrac{a}{b}\)</span>，那么 <spanclass="math inline">\(x^{-1}=\dfrac{b}{a}\)</span>。</li></ol><p>各种性质，运算律的证明和 <spanclass="math inline">\(\mathbb{Z}\)</span>上的大差不差，因此这里不过多赘述。这也说明了，<spanclass="math inline">\(\mathbb{Q}\)</span> 是环.</p><p>此外 <span class="math inline">\(\mathbb{Q}\)</span>为域，这意味着</p><ol type="1"><li><span class="math inline">\(\mathbb{Q}\)</span> 为交换环。</li><li><span class="math inline">\(\mathbb{Q}\)</span>中的每个元素都有倒数。</li></ol><p>至此，我们终于定义完成了从正整数到有理数，以后终于可以不再顾忌的使用这些数字（和运算律）了。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群论</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瞎谈点积</title>
    <link href="/posts/21685/"/>
    <url>/posts/21685/</url>
    
    <content type="html"><![CDATA[<p><spanclass="math inline">\(\newcommand{\lm}{\begin{bmatrix}}\newcommand{\rm}{\end{bmatrix}}\newcommand{\dis}[1]{\left\|#1\right\|}\)</span>从标题可以看出这篇文章时关于点积的。本文讨论的是平面点积。本文记 <spanclass="math inline">\(\vec{a}\)</span> 的长度为 <spanclass="math inline">\(\left\|\vec{a}\right\|\)</span>。</p><p>参与点积运算的是两个向量。架设有两个向量 <spanclass="math inline">\(\vec{a}=\begin{bmatrix}x_0 \\y_0\end{bmatrix},\vec{b}=\begin{bmatrix}x_1 \\y_1\end{bmatrix}\)</span>，则我们定义点积为 <spanclass="math inline">\(\vec{a} \cdot\vec{b}=x_0x_1+y_0y_1\)</span>。点积是一个很神奇的东西，先说它的几条性质。</p><h3 id="性质">性质</h3><h4 id="交换律">交换律</h4><p>对于任意 <span class="math inline">\(\vec{a}=\begin{bmatrix}x_0 \\y_0\end{bmatrix},\vec{b}=\begin{bmatrix}x_1 \\y_1\end{bmatrix}\)</span>，都有 <span class="math inline">\(\vec{a}\cdot \vec{b}=\vec{b} \cdot \vec{a}\)</span>。 证明：显而易见吧。 <spanclass="math display">\[\displaylines{\vec{a} \cdot \vec{b}=x_0x_1+y_0y_1\\\vec{b} \cdot \vec{a}=x_1x_0+y_1y_0=x_0x_1+y_0y_1}\]</span></p><h4 id="双线性">双线性</h4><p>双线性意味着一下两点：</p><ol type="1"><li><spanclass="math inline">\(\vec{a}\cdot(\vec{b}+\vec{c})=\vec{a}\cdot\vec{b}+\vec{a}\cdot \vec{c}\)</span></li><li><spanclass="math inline">\(\vec{a}\cdot(k\vec{b})=k(\vec{a}\cdot\vec{b})\)</span>证明都不难，根据定义展开计算即可，在这里不做赘述。</li></ol><h4 id="正定性">正定性</h4><p><del>其实就是非负性</del></p><p>正定性意味着对于任何向量 <span class="math inline">\(\vec{a}\in\mathbb{R}^2\)</span>，<spanclass="math inline">\(\vec{a}\cdot\vec{a}\geq 0\)</span>。取等号当且仅当<span class="math inline">\(\vec{a}\)</span> 是零向量。</p><p>证明也很简单，假设 <span class="math inline">\(\vec{a}=\lmx\\y\rm\)</span> 注意到 <spanclass="math inline">\(\vec{a}\cdot\vec{a}=x^2+y^2=\dis{\vec{a}}^2\)</span>。显而易见，长度是不能为负的。</p><p>以上就是点积的三条性质，这些性质大多用来参与运算。</p><h3 id="关系">关系</h3><p>这还不是点积最神奇的地方，最神奇的地方在于点积和两个向量的长度和夹角都有关。</p><ol type="1"><li><p>对于单位圆上的向量 <spanclass="math inline">\(\vec{a},\vec{b}\)</span>，其夹角为 <spanclass="math inline">\(\theta\)</span>，都有 <spanclass="math inline">\(\vec{a}\cdot\vec{b}=\cos \theta\)</span>。</p><p>证明：假设向量 <span class="math inline">\(\vec{b}\)</span> 是由<span class="math inline">\(\vec{a}\)</span> 逆时针 <spanclass="math inline">\(\theta\)</span>度之后得到的，由于众所周知，逆时针旋转 <spanclass="math inline">\(\theta\)</span> 度之后 的旋转矩阵是 <spanclass="math inline">\(\lm \cos \theta &amp; -\sin \theta \\ \sin \theta&amp; \cos \theta \rm\)</span>。设 <spanclass="math inline">\(\vec{a}=\lm x\\y\rm\)</span>，那么有 <spanclass="math inline">\(\vec{b}=\vec{a}\lm \cos \theta &amp; -\sin \theta\\ \sin \theta &amp; \cos \theta \rm=\lm x\\y\rm \lm \cos \theta &amp;-\sin \theta \\ \sin \theta &amp; \cos \theta \rm=\lmx\cos\theta-y\sin\theta \\ x\sin\theta+y\cos\theta\rm\)</span>。所以<span class="math display">\[\displaylines{\vec{a}\cdot\vec{b}&amp;=x(x\cos\theta-y\sin\theta)+y(x\sin\theta+y\cos\theta)\\&amp;=x^2\cos\theta-xy\sin \theta+xy\sin \theta +y^2\cos\theta\\&amp;=(x^2+y^2)\cos \theta=\dis{\vec{a}}\cos \theta=\cos \theta}\]</span>证毕。</p></li><li><p><spanclass="math inline">\(\vec{a}\cdot\vec{b}=\dis{\vec{a}}\dis{\vec{b}}\cos\theta\)</span>。</p><p>证明：既然有了单位向量点积的关系，我们不如将这两个向量转化为单位向量。显然<spanclass="math inline">\(\dfrac{1}{\dis{\vec{a}}}\vec{a},\dfrac{1}{\dis{\vec{b}}}\vec{b}\)</span>都是单位向量，而且夹角的大小不变。因此 <spanclass="math inline">\((\dfrac{1}{\dis{\vec{a}}}\vec{a})\cdot(\dfrac{1}{\dis{\vec{b}}}\vec{b})=\cos\theta\)</span>。再用双线性得<spanclass="math inline">\(\dfrac{1}{\dis{\vec{a}}\dis{\vec{b}}}(\vec{a}\cdot\vec{b})=\cos\theta\)</span>，移项就可以得到<spanclass="math inline">\(\vec{a}\cdot\vec{b}=\dis{\vec{a}}\dis{\vec{b}}\cos\theta\)</span>。这也说明了一点，就是两个向量垂直当且仅当点积等于一，因为这时候<span class="math inline">\(\cos\theta=0\)</span>。</p></li></ol><p>以上两点可以看出，点积和参与运算向量的长度和夹角都有关。为什么呢？<img src="/img/点积1.png" /> 如图，设<spanclass="math inline">\(\vec{a}=\lm x_0\\y_0\rm,\vec{b}=\lm x_1 \\ y_1\rm\)</span>将 <span class="math inline">\(\vec{b}\)</span> 顺时针旋转<span class="math inline">\(90^\circ\)</span> 后得到 <spanclass="math inline">\(b^\prime =\lmy_1\\-x_1\rm\)</span>，因此整个阴影四边形的面积就是 <spanclass="math inline">\(\operatorname{det}(\lm y_1 &amp; x_0\\-x_1&amp;y_0 \rm)=y_0y_1-(-x_1x_0)=x_0x_1+y_0y_1\)</span>，恰好是 <spanclass="math inline">\(\vec{a}\cdot\vec{b}\)</span>如果你不懂行列式，也没关系。根据三角函数我们可以知道 <spanclass="math display">\[GD=\dis{\vec{b^\prime}}\sin\alpha=\dis{\vec{b}}\sin\alpha=\dis{\vec{b}}\cos(90^\circ-\alpha)=\dis{\vec{b}}\cos\theta\]</span> 所以平行四边形的面积为 <spanclass="math inline">\(\dis{\vec{a}}\dis{\vec{b}}\cos\theta\)</span>。这样就解释了为什么点积和长度，夹角都有关系。<del>行列式不也是吗</del></p><h3 id="应用">应用</h3><p>由于这些神奇的特性，我们可以有点积做一些有趣的事情。</p><h4 id="正交分解公式">正交分解公式</h4><p>也可以叫投影公式，<del>起这个标题只是因为听起来更高大上。</del></p><p>这个公式的作用是这样的：给定两个向量 <spanclass="math inline">\(\vec{a},\vec{b}\)</span>，将 <spanclass="math inline">\(\vec{a}\)</span> 拆成 <spanclass="math inline">\(\vec{a_0}+\vec{a_1}\)</span> 的形式，使得 <spanclass="math inline">\(\vec{a_0}\perp \vec{b},\vec{a_1}\parallel\vec{b}\)</span>。其中一个方法是线性变换，另一个就是点积。</p><p>先给出一个解析几何的方法： 假设 <spanclass="math inline">\(\vec{a}=\vec{a_0}+\vec{a_1}\)</span>，由于 <spanclass="math inline">\(\vec{a_1}\parallel\vec{b}\)</span>，所以我们可以设<span class="math inline">\(\vec{a_1}=k\vec{b}\)</span>，可以得到 <spanclass="math inline">\(\vec{a}=\vec{a_0}+k\vec{b}\)</span>，两边同时点积得<spanclass="math inline">\(\vec{a}\cdot\vec{b}=\vec{a_0}\cdot\vec{b}+k(\vec{b}\cdot\vec{b})\)</span>，由于<span class="math inline">\(\vec{a_0}\perp \vec{b}\)</span>，所以 <spanclass="math inline">\(\vec{a_0}\cdot\vec{b}=0\)</span>。因此 <spanclass="math inline">\(\vec{a}\cdot\vec{b}=k(\vec{b}\cdot\vec{b})\)</span>，<spanclass="math inline">\(k=\dfrac{\vec{a}\cdot\vec{b}}{\vec{b}\cdot\vec{b}}\)</span>。带入得<spanclass="math inline">\(\vec{a_1}=\dfrac{\vec{a}\cdot\vec{b}}{\vec{b}\cdot\vec{b}}\vec{b}\)</span>。<del>这是怎么发现的</del></p><p>再给出一个其他的理解方法： <img src="/img/点积2.png" />容易看出，<spanclass="math inline">\(\dfrac{\vec{a}\cdot\vec{b}}{\vec{b}\cdot\vec{b}}\)</span>实际上是 <span class="math inline">\(GD\)</span> 和 <spanclass="math inline">\(OC\)</span> 的比值，等于 <spanclass="math inline">\(OI\)</span> 和 <spanclass="math inline">\(OH\)</span> 的比值（通过三垂直可以知道 <spanclass="math inline">\(\triangle BGO \cong \triangleOGD\)</span>）。因此将这个数乘上 <spanclass="math inline">\(\vec{b}\)</span> 自然就是 <spanclass="math inline">\(\vec{OI}\)</span>，也就是得到的 <spanclass="math inline">\(\vec{a_1}\)</span>，太好了，数学诚不我欺。</p><h4 id="柯西不等式">柯西不等式</h4><p>柯西不等式，又叫Cauchy-Schwarz不等式，指的是这个 <spanclass="math inline">\(\left|\vec{a}\cdot\vec{b}\right|\leq\dis{\vec{a}}\dis{\vec{b}}\)</span>。结合刚才的平行四边形和 <spanclass="math inline">\(\vec{a}\cdot\vec{b}=\dis{\vec{a}}\dis{\vec{b}}\cos\theta\)</span>可以很快推出来，因为 <span class="math inline">\(\cos\theta\)</span> 在<span class="math inline">\([-1,+1]\)</span> 之间，取 <spanclass="math inline">\(\pm 1\)</span> 时当前仅当 <spanclass="math inline">\(\theta=0^\circ\)</span>。</p><p>还有另外一种证明方法，就是将 <spanclass="math inline">\(\vec{a}\)</span> 进行正交分解，得 <spanclass="math inline">\(\vec{a}=\vec{a_0}+\vec{a_1}\)</span>。移项得 <spanclass="math inline">\(\vec{a_0}=\vec{a}-\vec{a_1}\)</span>，两边同时点积得<span class="math display">\[\displaylines{\vec{a_0}\cdot\vec{a_0}&amp;=\vec{a_0}\cdot(\vec{a}-\vec{a_1})\\&amp;= \vec{a_0}\cdot\vec{a}-\vec{a_0}\cdot\vec{a_0}\\&amp;= \vec{a_0}\cdot\vec{a}\\&amp;=(\vec{a}-\dfrac{\vec{a}\cdot\vec{b}}{\vec{b}\cdot\vec{b}}\vec{b})\cdot\vec{a}\\&amp;=\vec{a}\cdot\vec{a}-\dfrac{\vec{a}\cdot\vec{b}}{\vec{b}\cdot\vec{b}}(\vec{a}\cdot\vec{b})\\&amp;=\dis{\vec{a}}^2-\dfrac{(\vec{a}\cdot\vec{b})^2}{\dis{\vec{b_0}}^2}=\dis{\vec{a_0}}\geq0}\]</span> 整理得 <span class="math display">\[\displaylines{\dis{\vec{a}}^2-\dfrac{(\vec{a}\cdot\vec{b})^2}{\dis{\vec{b_0}}^2}\geq0\\\dis{\vec{a}}^2\geq \dfrac{(\vec{a}\cdot\vec{b})^2}{\dis{\vec{b_0}}^2}\\\dis{\vec{a}}^2\dis{\vec{b_0}}^2\ge(\vec{a}\cdot\vec{b})^2\\\sqrt{\dis{\vec{a}}^2\dis{\vec{b_0}}^2}\ge\sqrt{(\vec{a}\cdot\vec{b})^2}\\\dis{\vec{a}}\dis{\vec{b_0}}\geq \left|\vec{a}\cdot\vec{b}\right|\\}\]</span> 证毕。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>Cartisian平面几何</category>
      
    </categories>
    
    
    <tags>
      
      <tag>几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划入门指北</title>
    <link href="/posts/61763/"/>
    <url>/posts/61763/</url>
    
    <content type="html"><![CDATA[<h3 id="从搜索的优化说起">从搜索的优化说起</h3><p>考虑这样题目：</p><blockquote><p>写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。<img src="/img/95pzs0ne.png" alt="来源：洛谷" /></p></blockquote><p>显然，我们可以从顶端开始，枚举每一条路径，求出其中的最大值。我们注意到，如果有一条路径可以到达某个点，之前的路径并不会影响之后走的路径。</p><p>举个例子：假如通过 <span class="math inline">\(7-8-1\)</span> 到达了<span class="math inline">\(1\)</span> 这个点，接下来打算走 <spanclass="math inline">\(1-4-6\)</span> 这几个点到达 <spanclass="math inline">\(6\)</span> 这个点，但加入你通过 <spanclass="math inline">\(7-3-1\)</span> 到达 <spanclass="math inline">\(1\)</span> 这个点，仍然可以走 <spanclass="math inline">\(1-4-6\)</span> 到达 <spanclass="math inline">\(6\)</span>。</p><p>因此，此时到达 <span class="math inline">\(1\)</span>的最优解在最后肯定比到达 <span class="math inline">\(1\)</span>的其它路径更优。因为之后无论什么路径，最有解和其他路径都可以走，而最优解有优于其他路径，因此肯定更优。比如图中<span class="math inline">\(7-8-1-7-5\)</span> 肯定比 <spanclass="math inline">\(7-3-1-7-5\)</span> 更优，因为到达 <spanclass="math inline">\(1\)</span> 这个点的路径更优。</p><p>所以，到达每个点的最优解只和到达上一个点的最优解有关。所以刚刚的搜索算法多了许多无效搜索。因为每个点的前面一个点只有两种可能（左和右两个点，最优解记作<span class="math inline">\(p_l\)</span>和<spanclass="math inline">\(p_r\)</span>）因此，如果将当前的数字记作 <spanclass="math inline">\(p_{rec}\)</span>，到达下一个点的最优路径为 <spanclass="math inline">\(\operatorname{max}(p_l,p_r)+p_{rec}\)</span>。我们只要枚举每层每个点，像这样求出最优解即可。像这样的算法叫做动态规划（DynamicProgramming，简称DP）。</p><h3 id="动态规划简介">动态规划简介</h3><p>接下来更加详细的介绍动态规划算法。</p><h4 id="概念解释">概念解释</h4><ol type="1"><li>在上面的例子中，求出 <span class="math inline">\(p_{rec}\)</span>要先求出 <span class="math inline">\(p_l\)</span> 和 <spanclass="math inline">\(p_r\)</span>。我们将求出 <spanclass="math inline">\(p_l,p_r\)</span> 称为 <spanclass="math inline">\(p_{rec}\)</span>的”子问题“，通常，子问题是一个数据规模更小的相同问题。<br /></li><li>在上文中，我们用点上的数字来描述一个问题，比如“到编号为 <spanclass="math inline">\(1\)</span>的点的最有解”，但实际上可能会优重复，而且查找并不方便。因此我们可以用行号列号来描述一个问题。比如“到第<span class="math inline">\(3\)</span> 行第 <spanclass="math inline">\(2\)</span>个点的最优解”。像这样描述一个子问题，叫做“状态”。<br /></li><li>在上面的例子中，我们按照行号枚举每个点。在这里，我们将一行的点分为一类，从上到下枚举。其中一类被称为动态规划的阶段，设计阶段时要保证，在解决一个问题前，要保证问题的所有子问题都被正确解决。<br /></li><li>上文的 <spanclass="math inline">\(\operatorname{max}(p_l,p_r)+p_{rec}\)</span>描述了如何从一个状态的到下一个状态（从子问题的最优解推导出问题的最优解），被称为“状态转移方程”。</li></ol><p>接下来考虑动态规划要满足的条件：</p><h4 id="最优子结构">最优子结构</h4><p>所谓最优子结构，是指以下两点</p><ol type="1"><li>到达每个状态前做出的决策并不会影响之后做出的决策（对应上文如果有一条路径可以到达某个点，之前的路径并不会影响之后走的路径）<br /></li><li>问题的最优解一定来自于子问题的最优解（对应上文到达每个点的最优解只和到达上一个点的最优解有关）</li></ol><h4 id="无后效性">无后效性</h4><p>无后效性是指，一个子问题的答案只依赖于在它之前解决子问题，不会受在它之后解决的子问题的影响。</p><p>在开头的例子中，经过了一个点是不能往回走到，因此满足无后效性。</p><h4 id="重叠子问题">重叠子问题</h4><p>重叠子问题是指，要解决多个问题往往依赖于一些相同的子问题。比如开头的例子中，求第<span class="math inline">\(3\)</span> 行第 <spanclass="math inline">\(1\)</span> 和第 <spanclass="math inline">\(2\)</span> 个数都依赖于第 <spanclass="math inline">\(2\)</span> 行第 <spanclass="math inline">\(1\)</span>个数的最优解。重叠子问题越多，dp算法效率越高。</p><h3 id="和其他算法的关系">和其他算法的关系</h3><h4 id="分治">分治</h4><p>DP可以看作是一种分治算法，将一个问题分解成多个子问题，当子问题足够容易解决时解决掉这些子问题，再用状态转移方程得到问题答案。 分治算法通常用递归来实现，我们也可以写出DP的递归写法（以开头的数字三角形为例）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">slove</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dp[i][j]!=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> dp[i][j];<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> dp[i][j]=arr[i][j];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dp[i][j]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">slove</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>),<span class="hljs-built_in">slove</span>(i<span class="hljs-number">-1</span>,j))+arr[i][j];<br>&#125;<br></code></pre></td></tr></table></figure>递归的运算次数再某些情况下会略小于接下来要说的递推写法，但是由于函数调用需要花时间，并且递归层数过深容易爆栈，因此采用递归写法实际上不一定比递推更优。</p><h4 id="递推">递推</h4><p>实际上，按阶段枚举每个点和递推也很是相似，都是通过子问题的解推出问题的解。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>        dp[i<span class="hljs-number">+1</span>][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">+1</span>][j],dp[i][j]+arr[i<span class="hljs-number">+1</span>][j]);<br>        dp[i<span class="hljs-number">+1</span>][j<span class="hljs-number">+1</span>]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">+1</span>][j<span class="hljs-number">+1</span>],dp[i][j]+arr[i<span class="hljs-number">+1</span>][j<span class="hljs-number">+1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 也可以这样写： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j])+arr[i][j];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>两种方法并没有太大的区别。</p><p>实际上不难发现，递归写法和递推的第二种写法是从问题的角度出发，而递归的第一种写法是从子问题推导出问题的解的角度出发的。</p><h4 id="图论">图论</h4><p>DP与图论关系很大，图论中的Floyd算法和Dijkstra算法都采用的DP的思想。</p><p>实际上，如果将状态看作图上的点，将状态之间的关系看作边，那么DP实际上就是再一张图上用BFS跑最短路/最长路。BFS第一次访问的节点（第一层）就是DP的第一阶段。以次类推。</p><p>由于DP的特性无后效性，所以图中显然没有环，因此这个算法是正确的。 这也引出了有后效性的一个常见做法：利用SPFA算法的迭代思想，多次迭代到某个状态的最优解。</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实像和虚像</title>
    <link href="/posts/12389/"/>
    <url>/posts/12389/</url>
    
    <content type="html"><![CDATA[<h3 id="实像">实像</h3><p>具体定义见物理课本。考虑实像的形成。我们将物看作许多个点光源，不难看出，成清晰实像形成的条件是从每个点光源上发出的光线会在光屏上投射要一个点上，如果不是一个点（而是一个光斑）成的像就会不清晰。</p><h3 id="虚像">虚像</h3><p>具体定义还是看物理课本。以平面镜为例，一般来说，会有这样的光路图。</p><p><img src="/img/平面镜1.png" alt="平面镜1.png" />怎么理解？经过平面镜反射后的光路，等价于撤去平面镜后位于C‘点的点光源发出的光线，C’点就是虚像的位置（既然等价，我们的大脑自然会认为C’点有东西了，这就是所谓虚像）。再举一个例子： <img src="/img/凸透镜3_1.png" alt="凸透镜3_1.png" />光源（实箭头）成的虚像（虚箭头）意味着，光源发出的经过凸透镜后的光线相当于撤去凸透镜后，在虚像处放置一个与虚像等大的光源发出的光路，所以大脑会认为虚像处有东西，看到虚像。</p>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凸透镜与凹透镜</title>
    <link href="/posts/4669/"/>
    <url>/posts/4669/</url>
    
    <content type="html"><![CDATA[<h2 id="凸透镜">凸透镜</h2><h3 id="成像原理">成像原理</h3><blockquote><p>关于实像和虚像的定义，请参见<ahref="http://%5B2409:8a20:c83:2f20:e594:587d:830c:4a90%5D:8001/shi-xiang-he-xu-xiang/">实像和虚像</a></p></blockquote><p>众所周知，凸透镜有聚光的作用。</p><ol type="1"><li>在一倍焦距以内，一个点光源发出的光线最后是这样的： <imgsrc="/img/凸透镜1.png" />此时经过凸透镜的光线的反射延长线交于H点，这个点光源会在H点成虚像。由于光线会比原来汇聚，所以H点到透镜的距离会大于点光源到透镜的距离。</li><li>当点光源位于一倍焦距之外是，光线是这个样子的。 <imgsrc="/img/凸透镜2.png" />此时经过凸透镜的光线会交于J点，再J点放置光屏，可以再光屏上成实像（即，J点会成点光源的实像）。这时，如果再J点右侧观察，J点相当于一个点光源（但是并不是点光源，只是有相同的效果）。注：其实并不是只有一个点光源发出的光线会像这样汇聚成一点，满足这些条件的光线可以不是从同一个光源上发出的，但是这些光线一定是等价于一个点光源发出的光线（折射时光路可逆），因此，我们可以用这些点光源代替这些光线。</li></ol><p>有了这些知识，我们就可以理解凸透镜的成像原理了。</p><ol type="1"><li><span class="math inline">\(u\ltf\)</span>时（方便起见<del>就是懒</del>，以后只保留关键光路） <imgsrc="/img/凸透镜3.png" />每个光源上的点光源会在同侧成虚像，点光源的所有虚像一起构成了光源的虚像。</li><li><span class="math inline">\(u\gt f\)</span>时 <imgsrc="/img/凸透镜4.png" />光源上的每个点光源发出的光线经过透镜后汇聚在另一侧的一个点上，这些点一起构成了实像（即，在另一侧成实像），在像的右侧，会有一个等效与光源的”光源“，有每个点光源的等效光源组成。最后，关于眼睛看到的东西：</li><li>成虚像时：看到的就是虚像。</li><li>成实像时：在实像右侧时，由于每个点光源会在右侧形成一个等效的“点光源”，眼球会调节焦距直到这些“点光源”在视网膜上成实像，这些“点光源”在视网膜上一起构成了光源的像，所以我们可以透过凸透镜看见像（像的位置就是实像所在的位置）。在实像左侧观测时，光路不等价与任何点光源发出的光路，所以大脑无法处理这些光路，什么像都观测不到。为什么只能透过透镜看到部分像？假设眼睛在T点，那么这些光线是眼睛可以看到的（光路保留临界光线）： <imgsrc="/img/凸透镜5.png" /> 这些是看不到的： <imgsrc="/img/凸透镜6.png" /> 所以只能看到一部分。</li></ol><h3 id="焦距物距和相距">焦距、物距和相距</h3><p>对于凸透镜来说，焦距<span class="math inline">\(f\)</span>、物距<spanclass="math inline">\(u\)</span>和相距<spanclass="math inline">\(v\)</span>有这样的关系： <spanclass="math display">\[\dfrac{1}{u}+\dfrac{1}{v}=\dfrac{1}{f}\]</span> 证明：还是这张图 <img src="/img/凸透镜7.png" /> <spanclass="math display">\[\displaylines{物距u=BO,相距v=B&#39;O,焦距f=OF=OF&#39; \\易证\triangle{ABO}\sim\triangle{A&#39;B&#39;O}且\triangle{HOF&#39;}\sim\triangle{A&#39;B&#39;F&#39;}\\\therefore AB:A&#39;B=BO:B&#39;O=u:v,\\HO:A&#39;B&#39;=OF&#39;:B&#39;F&#39;=f:v-f\\\because AB=HO\\\therefore AB:A&#39;B=HO:A&#39;B\\\therefore u:v=f:(v-f)\\vf=u(v-f)\\vf=uv-uf\\vf+uf=uv\\(u+v)f=uv\\u+v=\dfrac{uv}{f}\\\dfrac{u+v}{uv}=\dfrac{1}{f}\\\dfrac{1}{u}+\dfrac{1}{v}=\dfrac{1}{f}}\]</span></p><h3 id="眼球">眼球</h3><p>晶状体本质上是一个凸透镜，外界光源通过这个透镜将像成在视网膜上，由感光细胞接受，由大脑处理形成了视觉。和所有凸透镜成像一样，最后在视网膜上成一个点的像不一定来自于一个点光源，最后的像也不一定是由实际的物发出的，眼睛只关心最后入眼的光线汇聚再视网膜上能不能成清晰的像。但是，如果可以，那么此时入眼的光线仍等价与一个光源的光线（既然等价，自然成的像一样，所以我们一般用这个光源来代替入眼光线）。</p><h3 id="显微镜和望远镜">显微镜和望远镜</h3><h4 id="原理">原理</h4><p>这两个原理是一样的，都是凸透镜组合，我们把靠近物的叫做物镜，另一个叫做目镜。物镜成实像，将在透镜右侧形成一个等效的”光源“（实像），目镜成”光源“的放大的虚像（起放大的作用）。为什么一定要用透镜组？ 1.单个透镜成实像：作为望远镜时，并不能起到望远的作用，因为像时缩小的（参见凸透镜成像规律）。作为显微镜，显然放大倍数不够大（或足够大的难以生产），而且不方便观测（人不一定在像的外侧，要人左右移动）。2. 单个透镜成虚像：对于两者：放大倍数都不够大（况且虚像会比原来远）。为什么一定要采用这种形式？如果物镜成虚像，由于凸透镜成虚像到透镜的距离会较物距更远，不便控制第二个目镜在放大倍数够大时一定成虚像。如果目镜成实像，那么观测时不一定在像的右侧，看到实像，需要人来回移动（而且有时实像很远），也不方便。</p><h4 id="大于两个透镜组合">大于两个透镜组合</h4><p>只要保证最后一个凸透镜成虚像，剩下的成实像，保证凸透镜之间的距离即可。</p><h4 id="透镜间距离">透镜间距离</h4><p>记相邻2个透镜距离<spanclass="math inline">\(d\)</span>.透镜1焦距<spanclass="math inline">\(f_1\)</span>，透镜2焦距<spanclass="math inline">\(f_2\)</span>，物距相距同理。 清晰范围：指将<spanclass="math inline">\(d\)</span>调节到该范围可以得到清晰的像（这个范围需要保证透镜1成的像在透镜2的成像范围之内）。可调节范围：指对于每一个物距<spanclass="math inline">\(u_1\)</span>，都能在这个范围内调节<spanclass="math inline">\(d\)</span>得到清晰的像。（就是在设计显微镜和望远镜时，设定的<spanclass="math inline">\(d\)</span>可以调整的范围）。</p><h5 id="望远镜">望远镜</h5><p>清晰：<span class="math inline">\(v_1\lt d\ltv_1+f_2\)</span>（范围内改变会导致虚像大小改变） 可调节范围（假设<spanclass="math inline">\(u_1\gt 2f_1\)</span>）<spanclass="math inline">\(f_1\lt d\lt 2f_1+f_2\)</span></p><h5 id="显微镜">显微镜</h5><p>清晰：<span class="math inline">\(v_1\lt d\ltv_1+f_2\)</span>（范围内改变会导致虚像大小改变） 可调节范围（假设<spanclass="math inline">\(f_1\lt u_1\lt 2f_1\)</span>）<spanclass="math inline">\(d\gt 2f_1\)</span></p><h5 id="多个透镜组合">多个透镜组合</h5><p>清晰：对于任意两个相邻的透镜（不包括倒数第一个和倒数第二个，即，两个透镜都成实像）都有<spanclass="math inline">\(v_1+f_2\ltd\)</span>（范围内改变会导致第二个镜头成的实像和<spanclass="math inline">\(v_2\)</span>改变,第二个透镜成放大像是有<spanclass="math inline">\(v_1+f_2\lt d\ltv_1+2f_2\)</span>,成缩小像时有<span class="math inline">\(d\gtv_1+2f_2\)</span>），对于最后两个透镜，满足<spanclass="math inline">\(v_1\lt d\lt v_1+f_2\)</span>。可调节范围：对于两个成实像的透镜，<span class="math inline">\(f_1+f_2\ltd\)</span>，对于最后两个透镜，<span class="math inline">\(d\gt2f_1\)</span>.</p><h2 id="凹透镜">凹透镜</h2><p>与凸透镜成虚像时差不多，只是相距小于物距，大小缩小，并且只成虚像。</p><h3 id="视力矫正">视力矫正</h3><p>近视眼看不起远处的物体，就让凹透镜将像成近一些（<spanclass="math inline">\(v\lt u\)</span>），就可以看清楚了。远视眼看不起近处的物体，就让凸透镜将像成远一些（<spanclass="math inline">\(u\gt v\)</span>），就可以看清楚了。</p>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光学</tag>
      
      <tag>透镜</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小孔成像</title>
    <link href="/posts/12013/"/>
    <url>/posts/12013/</url>
    
    <content type="html"><![CDATA[<p>小孔成像，顾名思义，就是再光源和光屏之间放一个小孔，观察光源的成像效果。发现小孔再光屏上成倒立实像。</p><p>我们再[[实像和虚像]]里曾讨论过实像的形成，小孔成像是怎么实现的？很简单，把点光源发出的其他光线挡住，只留下一束光线打在光屏上。<img src="img/小孔成像2.png" /></p><p><img src="img/小孔成像3.png" />这样就做到了每个点光源上发出的光线会在光屏上投射要一个点上。</p><p>严格意义来说，其实并不是一个点，构成像的单位（即，每个点光源投射到光屏上的形状）是孔的形状（而不是一个点）。像有许多个”单位“构成（光源上的每个点光源都会留下一个）。这样就可以解释许多现象，比如将孔遮去一部分（或改变孔的大小）只会改变构成像的”单位“，减少打到光屏上光的数量，不会使像不完整或大小产生改变。大孔成斑是因为一个单位太大，分辨不出像的形状（极度模糊）。</p><blockquote><p>其实还有一种理解，就是光源通过孔上的每一个点会再光屏上成一个像，光源的像有一个个的这样的像组成，也能解释。比如大孔成斑是因为这样像太小，分辨不出来。其他类似。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STAOI G Round 4 T1题解</title>
    <link href="/posts/63036/"/>
    <url>/posts/63036/</url>
    
    <content type="html"><![CDATA[<h2 id="特解">特解</h2><p>先来考虑方程 <span class="math inline">\(\begin{cases}x+y=A\\x\operatorname{AND} y =B\end{cases}\)</span> 的一组特解。由于按位与<strong>不进位</strong>，并且 <span class="math inline">\(a\operatorname{AND} b=1\)</span> 当且仅当 <spanclass="math inline">\(a=b=1\)</span> ,这意味这 <spanclass="math inline">\(B\)</span> 的二进制中有一位为 <spanclass="math inline">\(1\)</span>，<spanclass="math inline">\(x,y\)</span> 相应的位上必定也为 <spanclass="math inline">\(1\)</span>，如果这位是 <spanclass="math inline">\(0\)</span>，那么只要保证 <spanclass="math inline">\(x,y\)</span> 中相应的位上不同时为 <spanclass="math inline">\(1\)</span> 就行。因此，我们可以先构造出一个满足<span class="math inline">\(a \operatorname{AND} b=B\)</span>的最小解，方法是：</p><ul><li><p>将 <span class="math inline">\(B\)</span>进行二进制分解，枚举其中的每一位。</p></li><li><p>如果这一位为 <span class="math inline">\(1\)</span>，则把 <spanclass="math inline">\(a,b\)</span> 相应的位上变为 <spanclass="math inline">\(1\)</span>。</p></li><li><p>如果这一位是 <span class="math inline">\(0\)</span>，就把 <spanclass="math inline">\(a,b\)</span> 中相应的位保持 <spanclass="math inline">\(0\)</span>。 最后得到的 <spanclass="math inline">\(x,y\)</span> 就是满足 <spanclass="math inline">\(a \operatorname{AND} b =B\)</span> 并且最小的<span class="math inline">\(a,b\)</span>。此时，我们改变 <spanclass="math inline">\(a\)</span> 中任意一位为 <spanclass="math inline">\(0\)</span> 的位并不会改变 <spanclass="math inline">\(a \operatorname{AND} b\)</span> 的值，而改变第<span class="math inline">\(i\)</span> 位相当于给这个数加上 <spanclass="math inline">\(2^{i-1}\)</span>，我们可以通过改变这些 <spanclass="math inline">\(0\)</span> 位来补齐 <spanclass="math inline">\(a+b\)</span> 和 <spanclass="math inline">\(A\)</span> 之间的差值。 设 <spanclass="math inline">\(a\)</span> 的二进制分解为 <spanclass="math inline">\(\overline{a_1a_2\cdots a_n}\)</span>，差值 <spanclass="math inline">\(c\)</span> 的二进制分解为 <spanclass="math inline">\(\overline{b_1b_2\cdotsc_m}\)</span>。显然，差值可以被补齐当且仅当 <spanclass="math inline">\(\forall i,b_i=1\)</span> 都有 <spanclass="math inline">\(a_i=0\)</span>，否则这一位无法被补齐。因此，我们只要检验<span class="math inline">\((a+c) \operatorname{AND} b\)</span>是否仍等于 <span class="math inline">\(B\)</span> 就行了，如果可以，那么<span class="math inline">\(x=a+c,y=b\)</span>就是一组特解，否则无解。</p><h2 id="齐次解">齐次解</h2><p>假设已经求出一组解 <span class="math inline">\(x,y\)</span>，设 <spanclass="math inline">\(x=(\overline{x_1x_2\cdotsx_n})_2,y=(\overline{y_1y_2\cdots y_n})_2\)</span>（不足的位向高位填<span class="math inline">\(0\)</span>补齐）。我们通过观察样例可以发现，如果 <spanclass="math inline">\(x_i,y_i\)</span> 一个为 <spanclass="math inline">\(1\)</span>，另一个为 <spanclass="math inline">\(0\)</span>，此时交换这两个数既不会改变 <spanclass="math inline">\(x \operatorname{AND} y\)</span>，也不会改变 <spanclass="math inline">\(x+y\)</span>，也就是说，交换这两位后的 <spanclass="math inline">\(x,y\)</span> 是一组不同的解。为了满足 <spanclass="math inline">\(x\ley\)</span>，我们只要保持最高的满足上面条件的两位保持不变，只交换后面不同的两位。</p></li></ul><h2 id="求和">求和</h2><p>接下来不妨设共有 <span class="math inline">\(n\)</span>个不同位，<span class="math inline">\(x_i,y_i\)</span>是其中一组不同位（不是最高的一位 ）。由加乘原理可以得知，一共由 <spanclass="math inline">\(2^n\)</span> 组解。其中，<spanclass="math inline">\(x_i=1,y_i=0\)</span> 的解有 <spanclass="math inline">\(2^{n-1}\)</span> 种，反过来也有 <spanclass="math inline">\(2^{n-1}\)</span> 种。在计算 <spanclass="math inline">\(y-x\)</span> 时，第一种情况会计算为 <spanclass="math display">\[\displaylines{(\overline{x_1x_2\cdots 1 \cdotsx_n})_2-(\overline{y_1y_2\cdots 0 \cdotsy_n})_2\\=(\overline{x_1x_2\cdots 0 \cdotsx_n})_2-(\overline{y_1y_2\cdots 0 \cdotsy_n})+(1-0)*2^{n-i}\\=(\overline{x_1x_2\cdots 0 \cdotsx_n})_2-(\overline{y_1y_2\cdots 0 \cdotsy_n})+2^{n-i}}\]</span>后一种情况会计算为 <spanclass="math display">\[\displaylines{(\overline{x_1x_2\cdots 0 \cdotsx_n})_2-(\overline{y_1y_2\cdots 1 \cdotsy_n})_2\\=(\overline{x_1x_2\cdots 0 \cdotsx_n})_2-(\overline{y_1y_2\cdots 0 \cdotsy_n})+(0-1)*2^{n-i}\\=(\overline{x_1x_2\cdots 0 \cdotsx_n})_2-(\overline{y_1y_2\cdots 0 \cdotsy_n})-2^{n-i}}\]</span>两者在相加时抵消。其它不同位也一样。因此，最后不同位并不会对最终答案有影响，最终答案是将<span class="math inline">\(x,y\)</span> 除去不同位后相减，在乘上 <spanclass="math inline">\(2^n\)</span>，最后对 <spanclass="math inline">\(m\)</span> 取模后的结果。</p><h2 id="ac-code">AC Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">65</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> a,m,t;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function">bitset&lt;N&gt; <span class="hljs-title">binary_fact</span><span class="hljs-params">(ull a)</span></span>&#123; <span class="hljs-comment">//二进制分解</span><br>    bitset&lt;65&gt; ret;<br>    <span class="hljs-keyword">for</span>(ull i=<span class="hljs-number">0</span>;a;a&gt;&gt;=<span class="hljs-number">1</span>,i++)&#123;<br>        ret[i]=a&amp;<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">lpow</span><span class="hljs-params">(ull a,ull b,ull p)</span></span>&#123; <span class="hljs-comment">//快速幂</span><br>    ull ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(ull i=<span class="hljs-number">1</span>;b;b&gt;&gt;=<span class="hljs-number">1</span>,i*=<span class="hljs-number">2</span>)&#123;<br>        ans*=<span class="hljs-built_in">pow</span>(a,(b&amp;<span class="hljs-number">1</span>)*i);<br>        ans=ans%m;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">alyze</span><span class="hljs-params">(<span class="hljs-type">const</span> bitset&lt;N&gt;&amp; a,<span class="hljs-type">const</span> bitset&lt;N&gt;&amp; b)</span></span>&#123; <span class="hljs-comment">//求出所有不同位的下标</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]^b[i])x.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!x.<span class="hljs-built_in">empty</span>())x.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">cau</span><span class="hljs-params">(bitset&lt;N&gt; a,bitset&lt;N&gt; b,vector&lt;<span class="hljs-type">int</span>&gt; al)</span></span>&#123; <span class="hljs-comment">//求结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:al)&#123;<br>        a[x]=b[x]=<span class="hljs-number">0</span>;<br>    &#125;<br>    ull x=a.<span class="hljs-built_in">to_ullong</span>(),y=b.<span class="hljs-built_in">to_ullong</span>();<br>    ull ans=((<span class="hljs-built_in">max</span>(x,y)-<span class="hljs-built_in">min</span>(x,y))%m)*(<span class="hljs-built_in">lpow</span>(<span class="hljs-number">2</span>,al.<span class="hljs-built_in">size</span>(),m));<br>    <span class="hljs-keyword">return</span> ans%m;<br>&#125;<br><br><span class="hljs-function">pair&lt;ull,ull&gt; <span class="hljs-title">spe_sol</span><span class="hljs-params">(bitset&lt;N&gt; a,bitset&lt;N&gt; b)</span></span>&#123; <span class="hljs-comment">//特解</span><br>    ull x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">if</span>(b[i]==<span class="hljs-number">1</span>)x+=(<span class="hljs-number">1ull</span>&lt;&lt;i),y+=(<span class="hljs-number">1ull</span>&lt;&lt;i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x+y&gt;a.<span class="hljs-built_in">to_ullong</span>())<span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> t=a.<span class="hljs-built_in">to_ullong</span>()-x-y;<br>    <span class="hljs-keyword">if</span>(((x+t)&amp;y)!=b.<span class="hljs-built_in">to_ullong</span>())<span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(x+t,y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cin&gt;&gt;t&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(ull i=<span class="hljs-number">0</span>;i&lt;t;i++)&#123;<br>        ull a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">auto</span> z=<span class="hljs-built_in">spe_sol</span>(<span class="hljs-built_in">binary_fact</span>(a),<span class="hljs-built_in">binary_fact</span>(b));<br>        bitset&lt;N&gt; p=z.first,q=z.second;<br>        vector&lt;<span class="hljs-type">int</span>&gt; k=<span class="hljs-built_in">alyze</span>(p,q);<br>        cout&lt;&lt;<span class="hljs-built_in">cau</span>(p,q,k)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>直线与线性变换</title>
    <link href="/posts/27741/"/>
    <url>/posts/27741/</url>
    
    <content type="html"><![CDATA[<p><spanclass="math inline">\(\newcommand{\A}{\begin{bmatrix}m&amp;p\\n&amp;q\end{bmatrix}}\newcommand{\lA}{\begin{bmatrix}m\\n\end{bmatrix}}\newcommand{\rA}{\begin{bmatrix}p\\q\end{bmatrix}}\newcommand{\lvec}{\begin{bmatrix}} \newcommand{\rvec}{\end{bmatrix}}\newcommand{\aftrsfer}[2]{\lvec m#1+p#2\\n#1+q#2\rvec}\newcommand{\transx}[2]{m#1+p#2}\newcommand{\transy}[2]{n#1+q#2}\)</span>本文研究一条经过二维线性变换的直线的解析式。我们假设变换前直线的解析式为<spanclass="math inline">\(y=k_0x+b_0\)</span>，变换后的解析式为<spanclass="math inline">\(y=k_1x+b_1\)</span>,变换矩阵<spanclass="math inline">\(A=\begin{bmatrix}m&amp;p\\n&amp;q\end{bmatrix}\)</span>.附：计算<span class="math inline">\((x,y)\)</span>变换后的结果的方法推到过程： <span class="math display">\[\A\lvec x\\ y \rvec =x\lA+y\rA=\lvec mx+py\\nx+qy\rvec\]</span> 结论：<spanclass="math inline">\(y=\dfrac{n+qk_0}{m+pk_0},b=\dfrac{mqb_0-npb_0}{m+pk_0}\)</span>（没错，<spanclass="math inline">\(b_1\)</span>的值里包含矩阵的行列式，我也不知道为什么）。</p><ol type="1"><li><span class="math inline">\(k_1\)</span>的推导<ol type="1"><li>直接计算 过程比较朴素，就是取两个<spanclass="math inline">\(x_0,x_1\)</span>求出变换后的点坐标，再用待定系数法或<spanclass="math inline">\(k=\dfrac{y-y&#39;}{x-x&#39;}\)</span>来求出<spanclass="math inline">\(k\)</span>.</li><li>众所周知，<span class="math inline">\(\begin{bmatrix}1\\k\end{bmatrix}\)</span>与直线的方向相同，直线进行变换后该向量变成了<spanclass="math display">\[A\begin{bmatrix}1\\k_0\end{bmatrix}=\A\begin{bmatrix}1\\k_0\end{bmatrix} =1\lA+k_0\rA=\begin{bmatrix}m+pk_0\\ n+qk_0\end{bmatrix}\]</span>易得上述结论。</li></ol></li><li><span class="math inline">\(b_1\)</span>的推导<ol type="1"><li>计算：原直线上任取一点<spanclass="math inline">\((x,kx+b)\)</span>,计算出变换后的点坐标<spanclass="math inline">\((x_1,y_1)\)</span>,然后<spanclass="math inline">\(b_1=k_1x_1-y_1\)</span>，将<spanclass="math inline">\(k_1\)</span>带进去计算就好了。</li><li>众所周知，<span class="math inline">\(b\)</span>其实是<spanclass="math inline">\(y\)</span>轴截距。因此，我们只要求出一个变换后落在<spanclass="math inline">\(y\)</span>轴上的一个点，求出其变换后的纵坐标即可，设这个点为<spanclass="math inline">\((x,k_0x+b_0)\)</span>，变换后的点为<spanclass="math inline">\((x_1,y_1)\)</span>. 不难求出<spanclass="math display">\[\displaylines{\lvec x\\k_0x+b_0\rvec\A=\aftrsfer{x}{(k_0x+b_0)}}\]</span> 所以<spanclass="math inline">\(x_1=\transx{x}{(k_0x+b_0)},y_1=\transy{x}{(k_0x+b_0)}\)</span>,因为这个点再<spanclass="math inline">\(y\)</span>轴上，因此<spanclass="math inline">\(x_1=0\)</span>. 因此<spanclass="math inline">\(\transx{x}{(k_0x+b)}=0\)</span>.解的<spanclass="math inline">\(x=\dfrac{-pb_0}{m+pk_0}\)</span>此时<spanclass="math inline">\(kx+b=\dfrac{mb_0}{m+pk_0}\)</span>,因此<spanclass="math inline">\(b_1=\transy{x}{(k_0x+b_0)}=\dfrac{-npb_0}{m+pk_0}+\dfrac{qmb_0}{m+pk_0}=\dfrac{mqb_0-npb_0}{m+pk_0}\)</span></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>Cartisian平面几何</category>
      
    </categories>
    
    
    <tags>
      
      <tag>几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>勾股定理</title>
    <link href="/posts/8575/"/>
    <url>/posts/8575/</url>
    
    <content type="html"><![CDATA[<p>本篇笔记探究<span class="math inline">\(a^2+b^2=c^2\)</span>的通解。方程齐次:<span class="math inline">\(a^2+b^2=c^2\Rightarrow(\lambdaa)^2+(\lambda b)^2=(\lambda c)^2\)</span> 不妨设<spanclass="math inline">\(a,b,c\in\mathbb{N}_1\)</span>且<spanclass="math inline">\(gcd(a,b,c)=1\)</span>. 则有 <spanclass="math display">\[\begin{cases}a=r^2-s^2\\b=2rs\\c=r^2+s^2\end{cases}\]</span> 或<span class="math inline">\(a,b\)</span>互换。 证明：</p><ol type="1"><li>a,b,c两奇一偶 因为<span class="math inline">\((2n)^2=4n^2\equiv0(mod4),(2n+1)^2=4n^2+4n+1\equiv1(mod 4) (n\in\mathbb{N_0})\)</span>. 而<spanclass="math inline">\(a^2+b^2=c^2\Rightarrow a^2+b^2\equivc^2(mod\space4)\)</span> 又因为<spanclass="math inline">\(a,b,c\)</span>两两互质，所以只有当<spanclass="math inline">\(a,b\)</span>一奇一偶，<spanclass="math inline">\(c\)</span>为奇数时有<spanclass="math display">\[a^2+b^2\equiv c^2\equiv1(mod4)\]</span>之后不妨设<span class="math inline">\(b\)</span>为偶。</li><li>分解因式。 <spanclass="math display">\[a^2=c^2-b^2=(c+b)(c-b)\]</span></li></ol><p>(记n的质因数分解中p的幂次为<spanclass="math inline">\(V_p(n)\)</span>) 所以对于<spanclass="math inline">\(a^2\)</span>的每个质因子p，有 <spanclass="math display">\[V_p(a^2)=2V_p(a)=V_p(c+b)+V_p(c-b)\]</span></p><ol start="3" type="1"><li><span class="math inline">\(c+b,c-b\)</span>互素由九章算术·更损相减术可知<spanclass="math inline">\(c+b,c-b\)</span>互素（即，<spanclass="math inline">\(c+b,c-b\)</span>没有公共质因子） <spanclass="math display">\[\displaylines{gcd(c+b,c-b)\\=gcd((c+b)-(c-b),c-b)\\=gcd(2b,c-b)\\=gcd(b,c-b)(c-b为奇）\\=gcd(b,c)\\=1}\]</span></li></ol><p>所以 <span class="math display">\[V_p(c+b)=2V_p(a),V_p(c-b)=0\]</span> 或</p><span class="math display">\[V_p(c-b)=2V_p(a),V_p(c+b)=0\]</span> 无论如何，<spanclass="math inline">\(c+b,c-b\)</span>都是平方数（每个质因子的幂次都是<spanclass="math inline">\(2\)</span>的倍数）。 于是我们设<spanclass="math inline">\(n^2=c+b,m^2=c-b\)</span> <spanclass="math display">\[\begin{cases}a=nm=(\dfrac{n+m}{2})^2-(\dfrac{n-m}{2})^2\\b=\dfrac{n^2-m^2}{2}=2·\dfrac{n+m}{2}·\dfrac{n-m}{2}\\c=\dfrac{n^2+m^2}{2}=(\dfrac{n+m}{2})^2+(\dfrac{n-m}{2})^2\end{cases}\]</span> 此时再设<spanclass="math inline">\(r=\dfrac{n+m}{2},s=\dfrac{n-m}{2}\)</span>就有<span class="math display">\[\begin{cases}a=r^2-s^2\\b=2rs\\c=r^2+s^2\end{cases}\]</span> 其实最开始分解因式时写成<spanclass="math inline">\(b^2=(c+a)(c-a)\)</span>会更简单一点，大致思路差不多。<p>#丢番图方程 #勾股定理</p><h2 id="同余数">同余数</h2><p>一个数<spanclass="math inline">\(n\in\mathbb{R}\)</span>是同余数当且仅当一下方程组有正整数解。<span class="math display">\[\begin{cases}a^2+b^2=c^2\\n=\frac{1}{2}ab\end{cases}\]</span> 因为<span class="math inline">\(a^2+b^2=c^2\)</span>的通解为<span class="math display">\[\begin{cases}a=r^2-s^2\\b=2rs\\c=r^2+s^2\end{cases}\]</span> 此时有 <span class="math display">\[n=\dfrac{1}{2}ab=\dfrac{1}{2}(r^2-s^2)(2rs)=rs(r^2-s^2)\]</span> 这就是同余数n的通解。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>几何</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
