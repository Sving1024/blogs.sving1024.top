<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/ti-jie/staoi-g-round-4-t1-ti-jie/"/>
      <url>/ti-jie/staoi-g-round-4-t1-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="特解"><a href="#特解" class="headerlink" title="特解"></a>特解</h2><p>先来考虑方程 $\begin{cases}x+y&#x3D;A\x \operatorname{AND} y &#x3D;B\end{cases}$ 的一组特解。<br>由于按位与<strong>不进位</strong>，并且 $a \operatorname{AND} b&#x3D;1$ 当且仅当 $a&#x3D;b&#x3D;1$ ,这意味这 $B$ 的二进制中有一位为 $1$，$x,y$ 相应的位上必定也为 $1$，如果这位是 $0$，那么只要保证 $x,y$ 中相应的位上不同时为 $1$ 就行。因此，我们可以先构造出一个满足 $a \operatorname{AND} b &#x3D;B$的最小解，方法是：</p><ul><li>将 $B$ 进行二进制分解，枚举其中的每一位。</li><li>如果这一位为 $1$，则把 $a,b$ 相应的位上变为 $1$。</li><li>如果这一位是 $0$，就把 $a,b$ 中相应的位保持 $0$。<br>最后得到的 $x,y$ 就是满足 $a \operatorname{AND} b &#x3D;B$ 并且最小的 $a,b$。此时，我们改变 $a$ 中任意一位为 $0$ 的位并不会改变 $a \operatorname{AND} b$ 的值，而改变第 $i$ 位相当于给这个数加上 $2^{i-1}$，我们可以通过改变这些 $0$ 位来补齐 $a+b$ 和 $A$ 之间的差值。<br>设 $a$ 的二进制分解为 $\overline{a_1a_2\cdots a_n}$，差值 $c$ 的二进制分解为 $\overline{b_1b_2\cdots c_m}$。显然，差值可以被补齐当且仅当 $\forall i,b_i&#x3D;1$ 都有 $a_i&#x3D;0$，否则这一位无法被补齐。因此，我们只要检验 $(a+c) \operatorname{AND} b$ 是否仍等于 $B$ 就行了，如果可以，那么 $x&#x3D;a+c,y&#x3D;b$ 就是一组特解，否则无解。</li></ul><h2 id="齐次解"><a href="#齐次解" class="headerlink" title="齐次解"></a>齐次解</h2><p>假设已经求出一组解 $x,y$，设 $x&#x3D;(\overline{x_1x_2\cdots x_n})_2,y&#x3D;(\overline{y_1y_2\cdots y_n})_2$（不足的位向高位填 $0$ 补齐）。我们通过观察样例可以发现，如果 $x_i,y_i$ 一个为 $1$，另一个为 $0$，此时交换这两个数既不会改变 $x \operatorname{AND} y$，也不会改变 $x+y$，也就是说，交换这两位后的 $x,y$ 是一组不同的解。为了满足 $x\le y$，我们只要保持最高的满足上面条件的两位保持不变，只交换后面不同的两位。</p><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><p>接下来不妨设共有 $n$ 个不同位，$x_i,y_i$ 是其中一组不同位（不是最高的一位 ）。由加乘原理可以得知，一共由 $2^n$ 组解。其中，$x_i&#x3D;1,y_i&#x3D;0$ 的解有 $2^{n-1}$ 种，反过来也有 $2^{n-1}$ 种。在计算 $y-x$ 时，第一种情况会计算为 $$\displaylines{(\overline{x_1x_2\cdots 1 \cdots x_n})_2-(\overline{y_1y_2\cdots 0 \cdots y_n})_2\&#x3D;(\overline{x_1x_2\cdots 0 \cdots x_n})_2-(\overline{y_1y_2\cdots 0 \cdots y_n})+(1-0)*2^{n-i}\&#x3D;(\overline{x_1x_2\cdots 0 \cdots x_n})_2-(\overline{y_1y_2\cdots 0 \cdots y_n})+2^{n-i}}$$后一种情况会计算为 $$\displaylines{(\overline{x_1x_2\cdots 0 \cdots x_n})_2-(\overline{y_1y_2\cdots 1 \cdots y_n})_2\&#x3D;(\overline{x_1x_2\cdots 0 \cdots x_n})_2-(\overline{y_1y_2\cdots 0 \cdots y_n})+(0-1)*2^{n-i}\&#x3D;(\overline{x_1x_2\cdots 0 \cdots x_n})_2-(\overline{y_1y_2\cdots 0 \cdots y_n})-2^{n-i}}$$两者在相加时抵消。其它不同位也一样。因此，最后不同位并不会对最终答案有影响，最终答案是将 $x,y$ 除去不同位后相减，在乘上 $2^n$，最后对 $m$ 取模后的结果。</p><h2 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">65</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> a,m,t;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function">bitset&lt;N&gt; <span class="hljs-title">binary_fact</span><span class="hljs-params">(ull a)</span></span>&#123; <span class="hljs-comment">//二进制分解</span><br>    bitset&lt;65&gt; ret;<br>    <span class="hljs-keyword">for</span>(ull i=<span class="hljs-number">0</span>;a;a&gt;&gt;=<span class="hljs-number">1</span>,i++)&#123;<br>        ret[i]=a&amp;<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">lpow</span><span class="hljs-params">(ull a,ull b,ull p)</span></span>&#123; <span class="hljs-comment">//快速幂</span><br>    ull ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(ull i=<span class="hljs-number">1</span>;b;b&gt;&gt;=<span class="hljs-number">1</span>,i*=<span class="hljs-number">2</span>)&#123;<br>        ans*=<span class="hljs-built_in">pow</span>(a,(b&amp;<span class="hljs-number">1</span>)*i);<br>        ans=ans%m;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">alyze</span><span class="hljs-params">(<span class="hljs-type">const</span> bitset&lt;N&gt;&amp; a,<span class="hljs-type">const</span> bitset&lt;N&gt;&amp; b)</span></span>&#123; <span class="hljs-comment">//求出所有不同位的下标</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]^b[i])x.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!x.<span class="hljs-built_in">empty</span>())x.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">cau</span><span class="hljs-params">(bitset&lt;N&gt; a,bitset&lt;N&gt; b,vector&lt;<span class="hljs-type">int</span>&gt; al)</span></span>&#123; <span class="hljs-comment">//求结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:al)&#123;<br>        a[x]=b[x]=<span class="hljs-number">0</span>;<br>    &#125;<br>    ull x=a.<span class="hljs-built_in">to_ullong</span>(),y=b.<span class="hljs-built_in">to_ullong</span>();<br>    ull ans=((<span class="hljs-built_in">max</span>(x,y)-<span class="hljs-built_in">min</span>(x,y))%m)*(<span class="hljs-built_in">lpow</span>(<span class="hljs-number">2</span>,al.<span class="hljs-built_in">size</span>(),m));<br>    <span class="hljs-keyword">return</span> ans%m;<br>&#125;<br><br><span class="hljs-function">pair&lt;ull,ull&gt; <span class="hljs-title">spe_sol</span><span class="hljs-params">(bitset&lt;N&gt; a,bitset&lt;N&gt; b)</span></span>&#123; <span class="hljs-comment">//特解</span><br>    ull x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">if</span>(b[i]==<span class="hljs-number">1</span>)x+=(<span class="hljs-number">1ull</span>&lt;&lt;i),y+=(<span class="hljs-number">1ull</span>&lt;&lt;i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x+y&gt;a.<span class="hljs-built_in">to_ullong</span>())<span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> t=a.<span class="hljs-built_in">to_ullong</span>()-x-y;<br>    <span class="hljs-keyword">if</span>(((x+t)&amp;y)!=b.<span class="hljs-built_in">to_ullong</span>())<span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(x+t,y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cin&gt;&gt;t&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(ull i=<span class="hljs-number">0</span>;i&lt;t;i++)&#123;<br>        ull a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">auto</span> z=<span class="hljs-built_in">spe_sol</span>(<span class="hljs-built_in">binary_fact</span>(a),<span class="hljs-built_in">binary_fact</span>(b));<br>        bitset&lt;N&gt; p=z.first,q=z.second;<br>        vector&lt;<span class="hljs-type">int</span>&gt; k=<span class="hljs-built_in">alyze</span>(p,q);<br>        cout&lt;&lt;<span class="hljs-built_in">cau</span>(p,q,k)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 丢番图方程 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/xiao-kong-cheng-xiang/"/>
      <url>/xiao-kong-cheng-xiang/</url>
      
        <content type="html"><![CDATA[<p>小孔成像，顾名思义，就是再光源和光屏之间放一个小孔，观察光源的成像效果。发现小孔再光屏上成倒立实像。</p><p>我们再[[实像和虚像]]里曾讨论过实像的形成，小孔成像是怎么实现的？很简单，把点光源发出的其他光线挡住，只留下一束光线打在光屏上。</p><p>![[小孔成像2.png]]![[小孔成像3.png]]<br>这样就做到了每个点光源上发出的光线会在光屏上投射要一个点上。</p><p>严格意义来说，其实并不是一个点，构成像的单位（即，每个点光源投射到光屏上的形状）是孔的形状（而不是一个点）。像有许多个”单位“构成（光源上的每个点光源都会留下一个）。这样就可以解释许多现象，比如将孔遮去一部分（或改变孔的大小）只会改变构成像的”单位“，减少打到光屏上光的数量，不会使像不完整或大小产生改变。大孔成斑是因为一个单位太大，分辨不出像的形状（极度模糊）。</p><blockquote><p>其实还有一种理解，就是光源通过孔上的每一个点会再光屏上成一个像，光源的像有一个个的这样的像组成，也能解释。比如大孔成斑是因为这样像太小，分辨不出来。其他类似。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/shi-xiang-he-xu-xiang/"/>
      <url>/shi-xiang-he-xu-xiang/</url>
      
        <content type="html"><![CDATA[<h3 id="实像"><a href="#实像" class="headerlink" title="实像"></a>实像</h3><p>具体定义见物理课本。<br>考虑实像的形成。我们将物看作许多个点光源，不难看出，成清晰实像形成的条件是从每个点光源上发出的光线会在光屏上投射要一个点上，如果不是一个点（而是一个光斑）成的像就会不清晰。</p><h3 id="虚像"><a href="#虚像" class="headerlink" title="虚像"></a>虚像</h3><p>具体定义还是看物理课本。<br>以平面镜为例，一般来说，会有这样的光路图。</p><p>![[平面镜1.png]]<br>怎么理解？经过平面镜反射后的光路，等价于撤去平面镜后位于C‘点的点光源发出的光线，C’点就是虚像的位置（既然等价，我们的大脑自然会认为C’点有东西了，这就是所谓虚像）。<br>再举一个例子：<br>![[凸透镜3 1.png]]<br>光源（实箭头）成的虚像（虚箭头）意味着，光源发出的经过凸透镜后的光线相当于撤去凸透镜后，在虚像处放置一个与虚像等大的光源发出的光路，所以大脑会认为虚像处有东西，看到虚像。</p>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/tu-tou-jing-yu-ao-tou-jing/"/>
      <url>/tu-tou-jing-yu-ao-tou-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="凸透镜"><a href="#凸透镜" class="headerlink" title="凸透镜"></a>凸透镜</h2><h3 id="成像原理"><a href="#成像原理" class="headerlink" title="成像原理"></a>成像原理</h3><blockquote><p>关于实像和虚像的定义，请参见<a href="http://[2409:8a20:c83:2f20:e594:587d:830c:4a90]:8001/shi-xiang-he-xu-xiang/">实像和虚像</a></p></blockquote><p>众所周知，凸透镜有聚光的作用。</p><ol><li>在一倍焦距以内，一个点光源发出的光线最后是这样的：<br>![[凸透镜1.png]]<br>此时经过凸透镜的光线的反射延长线交于H点，这个点光源会在H点成虚像。由于光线会比原来汇聚，所以H点到透镜的距离会大于点光源到透镜的距离。</li><li>当点光源位于一倍焦距之外是，光线是这个样子的。<br>![[凸透镜2.png]]<br>此时经过凸透镜的光线会交于J点，再J点放置光屏，可以再光屏上成实像（即，J点会成点光源的实像）。这时，如果再J点右侧观察，J点相当于一个点光源（但是并不是点光源，只是有相同的效果）。<br> 注：其实并不是只有一个点光源发出的光线会像这样汇聚成一点，满足这些条件的光线可以不是从同一个光源上发出的，但是这些光线一定是等价于一个点光源发出的光线（折射时光路可逆），因此，我们可以用这些点光源代替这些光线。</li></ol><p>有了这些知识，我们就可以理解凸透镜的成像原理了。</p><ol><li>$u\lt f$时（方便起见<del>就是懒</del>，以后只保留关键光路）<br>![[凸透镜3.png]]<br>每个光源上的点光源会在同侧成虚像，点光源的所有虚像一起构成了光源的虚像。</li><li>$u\gt f$时<br>![[凸透镜4.png]]<br>光源上的每个点光源发出的光线经过透镜后汇聚在另一侧的一个点上，这些点一起构成了实像（即，在另一侧成实像），在像的右侧，会有一个等效与光源的”光源“，有每个点光源的等效光源组成。<br>最后，关于眼睛看到的东西：</li><li>成虚像时：看到的就是虚像。</li><li>成实像时：在实像右侧时，由于每个点光源会在右侧形成一个等效的“点光源”，眼球会调节焦距直到这些“点光源”在视网膜上成实像，这些“点光源”在视网膜上一起构成了光源的像，所以我们可以透过凸透镜看见像（像的位置就是实像所在的位置）。在实像左侧观测时，光路不等价与任何点光源发出的光路，所以大脑无法处理这些光路，什么像都观测不到。<br>为什么只能透过透镜看到部分像？<br>  假设眼睛在T点，那么这些光线是眼睛可以看到的（光路保留临界光线）：<br>  ![[凸透镜5.png]]<br>  这些是看不到的：<br>  ![[凸透镜6.png]]<br>  所以只能看到一部分。</li></ol><h3 id="焦距、物距和相距"><a href="#焦距、物距和相距" class="headerlink" title="焦距、物距和相距"></a>焦距、物距和相距</h3><p>对于凸透镜来说，焦距$f$、物距$u$和相距$v$有这样的关系：<br>$$<br>\dfrac{1}{u}+\dfrac{1}{v}&#x3D;\dfrac{1}{f}<br>$$<br>证明：还是这张图<br>![[凸透镜7.png]]<br>$$<br>\displaylines{<br>物距u&#x3D;BO,相距v&#x3D;B’O,焦距f&#x3D;OF&#x3D;OF’ \<br>易证\triangle{ABO}\sim\triangle{A’B’O}且\triangle{HOF’}\sim\triangle{A’B’F’} \<br>\therefore AB:A’B&#x3D;BO:B’O&#x3D;u:v,\<br>HO:A’B’&#x3D;OF’:B’F’&#x3D;f:v-f\<br>\because AB&#x3D;HO\<br>\therefore AB:A’B&#x3D;HO:A’B\<br>\therefore u:v&#x3D;f:(v-f)\<br>vf&#x3D;u(v-f)\<br>vf&#x3D;uv-uf\<br>vf+uf&#x3D;uv\<br>(u+v)f&#x3D;uv\<br>u+v&#x3D;\dfrac{uv}{f}\<br>\dfrac{u+v}{uv}&#x3D;\dfrac{1}{f}\<br>\dfrac{1}{u}+\dfrac{1}{v}&#x3D;\dfrac{1}{f}<br>}<br>$$</p><h3 id="眼球"><a href="#眼球" class="headerlink" title="眼球"></a>眼球</h3><p>晶状体本质上是一个凸透镜，外界光源通过这个透镜将像成在视网膜上，由感光细胞接受，由大脑处理形成了视觉。<br>    和所有凸透镜成像一样，最后在视网膜上成一个点的像不一定来自于一个点光源，最后的像也不一定是由实际的物发出的，眼睛只关心最后入眼的光线汇聚再视网膜上能不能成清晰的像。但是，如果可以，那么此时入眼的光线仍等价与一个光源的光线（既然等价，自然成的像一样，所以我们一般用这个光源来代替入眼光线）。</p><h3 id="显微镜和望远镜"><a href="#显微镜和望远镜" class="headerlink" title="显微镜和望远镜"></a>显微镜和望远镜</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>这两个原理是一样的，都是凸透镜组合，我们把靠近物的叫做物镜，另一个叫做目镜。物镜成实像，将在透镜右侧形成一个等效的”光源“（实像），目镜成”光源“的放大的虚像（起放大的作用）。<br>为什么一定要用透镜组？<br>    1. 单个透镜成实像：作为望远镜时，并不能起到望远的作用，因为像时缩小的（参见凸透镜成像规律）。作为显微镜，显然放大倍数不够大（或足够大的难以生产），而且不方便观测（人不一定在像的外侧，要人左右移动）。<br>    2. 单个透镜成虚像：对于两者：放大倍数都不够大（况且虚像会比原来远）。<br>为什么一定要采用这种形式？<br>    如果物镜成虚像，由于凸透镜成虚像到透镜的距离会较物距更远，不便控制第二个目镜在放大倍数够大时一定成虚像。<br>    如果目镜成实像，那么观测时不一定在像的右侧，看到实像，需要人来回移动（而且有时实像很远），也不方便。</p><h4 id="大于两个透镜组合"><a href="#大于两个透镜组合" class="headerlink" title="大于两个透镜组合"></a>大于两个透镜组合</h4><p>只要保证最后一个凸透镜成虚像，剩下的成实像，保证凸透镜之间的距离即可。</p><h4 id="透镜间距离"><a href="#透镜间距离" class="headerlink" title="透镜间距离"></a>透镜间距离</h4><p>记相邻2个透镜距离$d$.透镜1焦距$f_1$，透镜2焦距$f_2$，物距相距同理。<br>清晰范围：指将$d$调节到该范围可以得到清晰的像（这个范围需要保证透镜1成的像在透镜2的成像范围之内）。<br>可调节范围：指对于每一个物距$u_1$，都能在这个范围内调节$d$得到清晰的像。（就是在设计显微镜和望远镜时，设定的$d$可以调整的范围）。</p><h5 id="望远镜"><a href="#望远镜" class="headerlink" title="望远镜"></a>望远镜</h5><p>清晰：$v_1\lt d\lt v_1+f_2$（范围内改变会导致虚像大小改变）<br>可调节范围（假设$u_1\gt 2f_1$）$f_1\lt d\lt 2f_1+f_2$</p><h5 id="显微镜"><a href="#显微镜" class="headerlink" title="显微镜"></a>显微镜</h5><p>清晰：$v_1\lt d\lt v_1+f_2$（范围内改变会导致虚像大小改变）<br>可调节范围（假设$f_1\lt u_1\lt 2f_1$）$d\gt 2f_1$</p><h5 id="多个透镜组合"><a href="#多个透镜组合" class="headerlink" title="多个透镜组合"></a>多个透镜组合</h5><p>清晰：对于任意两个相邻的透镜（不包括倒数第一个和倒数第二个，即，两个透镜都成实像）都有$v_1+f_2\lt d$（范围内改变会导致第二个镜头成的实像和$v_2$改变,第二个透镜成放大像是有$v_1+f_2\lt d\lt v_1+2f_2$,成缩小像时有$d\gt v_1+2f_2$），对于最后两个透镜，满足$v_1\lt d\lt v_1+f_2$。<br>可调节范围：对于两个成实像的透镜，$f_1+f_2\lt d$，对于最后两个透镜，$d\gt 2f_1$.</p><h2 id="凹透镜"><a href="#凹透镜" class="headerlink" title="凹透镜"></a>凹透镜</h2><p>与凸透镜成虚像时差不多，只是相距小于物距，大小缩小，并且只成虚像。</p><h3 id="视力矫正"><a href="#视力矫正" class="headerlink" title="视力矫正"></a>视力矫正</h3><p>近视眼看不起远处的物体，就让凹透镜将像成近一些（$v\lt u$），就可以看清楚了。<br>远视眼看不起近处的物体，就让凸透镜将像成远一些（$u\gt v$），就可以看清楚了。</p>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/shu-lun/gou-gu-ding-li/"/>
      <url>/shu-lun/gou-gu-ding-li/</url>
      
        <content type="html"><![CDATA[<p>本篇笔记探究$a^2+b^2&#x3D;c^2$的通解。<br>方程齐次:$a^2+b^2&#x3D;c^2\Rightarrow(\lambda a)^2+(\lambda b)^2&#x3D;(\lambda c)^2$<br>不妨设$a,b,c\in\mathbb{N}_1$且$gcd(a,b,c)&#x3D;1$.<br>则有<br>$$<br>\begin{cases}<br>a&#x3D;r^2-s^2\<br>b&#x3D;2rs\<br>c&#x3D;r^2+s^2<br>\end{cases}<br>$$<br>或$a,b$互换。<br>证明：</p><ol><li>a,b,c两奇一偶<br>因为$(2n)^2&#x3D;4n^2\equiv0(mod 4),(2n+1)^2&#x3D;4n^2+4n+1\equiv1(mod 4) (n\in\mathbb{N_0})$.<br>而$a^2+b^2&#x3D;c^2\Rightarrow a^2+b^2\equiv c^2(mod\space4)$<br>又因为$a,b,c$两两互质，所以只有当$a,b$一奇一偶，$c$为奇数时有$$a^2+b^2\equiv c^2\equiv1(mod4)$$<br>之后不妨设$b$为偶。</li><li>分解因式。<br>$$a^2&#x3D;c^2-b^2&#x3D;(c+b)(c-b)$$</li></ol><p>(记n的质因数分解中p的幂次为$V_p(n)$)<br>所以对于$a^2$的每个质因子p，有<br>$$<br>V_p(a^2)&#x3D;2V_p(a)&#x3D;V_p(c+b)+V_p(c-b)<br>$$<br>3. $c+b,c-b$互素<br>由九章算术·更损相减术可知$c+b,c-b$互素（即，$c+b,c-b$没有公共质因子）<br>$$<br>\displaylines{gcd(c+b,c-b)\<br>&#x3D;gcd((c+b)-(c-b),c-b)\<br>&#x3D;gcd(2b,c-b)\<br>&#x3D;gcd(b,c-b)(c-b为奇）\<br>&#x3D;gcd(b,c)\<br>&#x3D;1}<br>$$</p><p>所以<br>$$<br>V_p(c+b)&#x3D;2V_p(a),V_p(c-b)&#x3D;0<br>$$<br>或</p><p>$$<br>V_p(c-b)&#x3D;2V_p(a),V_p(c+b)&#x3D;0<br>$$<br>无论如何，$c+b,c-b$都是平方数（每个质因子的幂次都是$2$的倍数）。<br>于是我们设$n^2&#x3D;c+b,m^2&#x3D;c-b$<br>$$<br>\begin{cases}<br>a&#x3D;nm&#x3D;(\dfrac{n+m}{2})^2-(\dfrac{n-m}{2})^2\<br>b&#x3D;\dfrac{n^2-m^2}{2}&#x3D;2·\dfrac{n+m}{2}·\dfrac{n-m}{2}\<br>c&#x3D;\dfrac{n^2+m^2}{2}&#x3D;(\dfrac{n+m}{2})^2+(\dfrac{n-m}{2})^2<br>\end{cases}<br>$$<br>此时再设$r&#x3D;\dfrac{n+m}{2},s&#x3D;\dfrac{n-m}{2}$就有<br>$$<br>\begin{cases}<br>a&#x3D;r^2-s^2\<br>b&#x3D;2rs\<br>c&#x3D;r^2+s^2<br>\end{cases}<br>$$<br>其实最开始分解因式时写成$b^2&#x3D;(c+a)(c-a)$会更简单一点，大致思路差不多。<br>#丢番图方程 #勾股定理</p><h2 id="同余数"><a href="#同余数" class="headerlink" title="同余数"></a>同余数</h2><p>一个数$n\in\mathbb{R}$是同余数当且仅当一下方程组有正整数解。<br>$$<br>\begin{cases}<br>a^2+b^2&#x3D;c^2\<br>n&#x3D;\frac{1}{2}ab<br>\end{cases}<br>$$<br>因为$a^2+b^2&#x3D;c^2$的通解为<br>$$<br>\begin{cases}<br>a&#x3D;r^2-s^2\<br>b&#x3D;2rs\<br>c&#x3D;r^2+s^2<br>\end{cases}<br>$$<br>此时有<br>$$<br>n&#x3D;\dfrac{1}{2}ab<br>&#x3D;\dfrac{1}{2}(r^2-s^2)(2rs)<br>&#x3D;rs(r^2-s^2)<br>$$<br>这就是同余数n的通解。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 丢番图方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/cartisian-ping-mian-ji-he/zhi-xian-yu-xian-xing-bian-huan/"/>
      <url>/cartisian-ping-mian-ji-he/zhi-xian-yu-xian-xing-bian-huan/</url>
      
        <content type="html"><![CDATA[<p>$\newcommand{\A}{\begin{bmatrix}m&amp;p\n&amp;q\end{bmatrix}} \newcommand{\lA}{\begin{bmatrix}m\n\end{bmatrix}} \newcommand{\rA}{\begin{bmatrix}p\q\end{bmatrix}} \newcommand{\lvec}{\begin{bmatrix}} \newcommand{\rvec}{\end{bmatrix}} \newcommand{\aftrsfer}[2]{\lvec m#1+p#2\n#1+q#2\rvec} \newcommand{\transx}[2]{m#1+p#2} \newcommand{\transy}[2]{n#1+q#2}$<br>本文研究一条经过二维线性变换的直线的解析式。<br>我们假设变换前直线的解析式为$y&#x3D;k_0x+b_0$，变换后的解析式为$y&#x3D;k_1x+b_1$,变换矩阵$A&#x3D;\begin{bmatrix}m&amp;p\n&amp;q\end{bmatrix}$.<br>附：计算$(x,y)$变换后的结果的方法<br>推到过程：<br>$$<br>\A\lvec x\ y \rvec &#x3D;x\lA+y\rA&#x3D;\lvec mx+py\nx+qy\rvec<br>$$<br>结论：$y&#x3D;\dfrac{n+qk_0}{m+pk_0},b&#x3D;\dfrac{mqb_0-npb_0}{m+pk_0}$（没错，$b_1$的值里包含矩阵的行列式，我也不知道为什么）。</p><ol><li>$k_1$的推导<ol><li>直接计算<br> 过程比较朴素，就是取两个$x_0,x_1$求出变换后的点坐标，再用待定系数法或$k&#x3D;\dfrac{y-y’}{x-x’}$来求出$k$.</li><li>众所周知，$\begin{bmatrix}1\ k\end{bmatrix}$与直线的方向相同，直线进行变换后该向量变成了$$A\begin{bmatrix}1\ k_0\end{bmatrix}&#x3D;\A\begin{bmatrix}1\k_0\end{bmatrix} &#x3D;1\lA+k_0\rA &#x3D;\begin{bmatrix}m+pk_0\ n+qk_0\end{bmatrix}$$<br> 易得上述结论。</li></ol></li><li>$b_1$的推导<ol><li>计算：原直线上任取一点$(x,kx+b)$,计算出变换后的点坐标$(x_1,y_1)$,然后$b_1&#x3D;k_1x_1-y_1$，将$k_1$带进去计算就好了。</li><li>众所周知，$b$其实是$y$轴截距。因此，我们只要求出一个变换后落在$y$轴上的一个点，求出其变换后的纵坐标即可，设这个点为$(x,k_0x+b_0)$，变换后的点为$(x_1,y_1)$.<br> 不难求出$$\displaylines{\lvec x\ k_0x+b_0\rvec\A&#x3D;\aftrsfer{x}{(k_0x+b_0)}}$$<br> 所以$x_1&#x3D;\transx{x}{(k_0x+b_0)},y_1&#x3D;\transy{x}{(k_0x+b_0)}$,因为这个点再$y$轴上，因此$x_1&#x3D;0$. 因此$\transx{x}{(k_0x+b)}&#x3D;0$.解的$x&#x3D;\dfrac{-pb_0}{m+pk_0}$此时$kx+b&#x3D;\dfrac{mb_0}{m+pk_0}$,因此$b_1&#x3D;\transy{x}{(k_0x+b_0)}&#x3D;\dfrac{-npb_0}{m+pk_0}+\dfrac{qmb_0}{m+pk_0}&#x3D;\dfrac{mqb_0-npb_0}{m+pk_0}$</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> Cartisian平面几何 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
