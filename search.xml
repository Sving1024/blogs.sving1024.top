<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>瞎谈点积</title>
      <link href="/jie-xi-ji-he/xia-tan-dian-ji/"/>
      <url>/jie-xi-ji-he/xia-tan-dian-ji/</url>
      
        <content type="html"><![CDATA[<p><spanclass="math inline">\(\newcommand{\lm}{\begin{bmatrix}}\newcommand{\rm}{\end{bmatrix}}\newcommand{\dis}[1]{\left\|#1\right\|}\)</span>从标题可以看出这篇文章时关于点积的。本文讨论的是平面点积。本文记 <spanclass="math inline">\(\vec{a}\)</span> 的长度为 <spanclass="math inline">\(\left\|\vec{a}\right\|\)</span>。</p><p>参与点积运算的是两个向量。架设有两个向量 <spanclass="math inline">\(\vec{a}=\begin{bmatrix}x_0 \\y_0\end{bmatrix},\vec{b}=\begin{bmatrix}x_1 \\y_1\end{bmatrix}\)</span>，则我们定义点积为 <spanclass="math inline">\(\vec{a} \cdot\vec{b}=x_0x_1+y_0y_1\)</span>。点积是一个很神奇的东西，先说它的几条性质。</p><h3 id="性质">性质</h3><h4 id="交换律">交换律</h4><p>对于任意 <span class="math inline">\(\vec{a}=\begin{bmatrix}x_0 \\y_0\end{bmatrix},\vec{b}=\begin{bmatrix}x_1 \\y_1\end{bmatrix}\)</span>，都有 <span class="math inline">\(\vec{a}\cdot \vec{b}=\vec{b} \cdot \vec{a}\)</span>。 证明：显而易见吧。 <spanclass="math display">\[\displaylines{\vec{a} \cdot \vec{b}=x_0x_1+y_0y_1\\\vec{b} \cdot \vec{a}=x_1x_0+y_1y_0=x_0x_1+y_0y_1}\]</span> #### 双线性 双线性意味着一下两点： 1. <spanclass="math inline">\(\vec{a}\cdot(\vec{b}+\vec{c})=\vec{a}\cdot\vec{b}+\vec{a}\cdot \vec{c}\)</span> 2. <spanclass="math inline">\(\vec{a}\cdot(k\vec{b})=k(\vec{a}\cdot\vec{b})\)</span>证明都不难，根据定义展开计算即可，在这里不做赘述。</p><h4 id="正定性">正定性</h4><p><del>其实就是非负性</del></p><p>正定性意味着对于任何向量 <span class="math inline">\(\vec{a}\in\mathbb{R}^2\)</span>，<spanclass="math inline">\(\vec{a}\cdot\vec{a}\geq 0\)</span>。取等号当且仅当<span class="math inline">\(\vec{a}\)</span> 是零向量。</p><p>证明也很简单，假设 <span class="math inline">\(\vec{a}=\lmx\\y\rm\)</span> 注意到 <spanclass="math inline">\(\vec{a}\cdot\vec{a}=x^2+y^2=\dis{\vec{a}}^2\)</span>。显而易见，长度是不能为负的。</p><p>以上就是点积的三条性质，这些性质大多用来参与运算。</p><h3 id="关系">关系</h3><p>这还不是点积最神奇的地方，最神奇的地方在于点积和两个向量的长度和夹角都有关。</p><ol type="1"><li><p>对于单位圆上的向量 <spanclass="math inline">\(\vec{a},\vec{b}\)</span>，其夹角为 <spanclass="math inline">\(\theta\)</span>，都有 <spanclass="math inline">\(\vec{a}\cdot\vec{b}=\cos \theta\)</span>。</p><p>证明：假设向量 <span class="math inline">\(\vec{b}\)</span> 是由<span class="math inline">\(\vec{a}\)</span> 逆时针 <spanclass="math inline">\(\theta\)</span>度之后得到的，由于众所周知，逆时针旋转 <spanclass="math inline">\(\theta\)</span> 度之后 的旋转矩阵是 <spanclass="math inline">\(\lm \cos \theta &amp; -\sin \theta \\ \sin \theta&amp; \cos \theta \rm\)</span>。设 <spanclass="math inline">\(\vec{a}=\lm x\\y\rm\)</span>，那么有 <spanclass="math inline">\(\vec{b}=\vec{a}\lm \cos \theta &amp; -\sin \theta\\ \sin \theta &amp; \cos \theta \rm=\lm x\\y\rm \lm \cos \theta &amp;-\sin \theta \\ \sin \theta &amp; \cos \theta \rm=\lmx\cos\theta-y\sin\theta \\ x\sin\theta+y\cos\theta\rm\)</span>。所以<span class="math display">\[\displaylines{\vec{a}\cdot\vec{b}&amp;=x(x\cos\theta-y\sin\theta)+y(x\sin\theta+y\cos\theta)\\&amp;=x^2\cos\theta-xy\sin \theta+xy\sin \theta +y^2\cos\theta\\&amp;=(x^2+y^2)\cos \theta=\dis{\vec{a}}\cos \theta=\cos \theta}\]</span>证毕。</p></li><li><p><spanclass="math inline">\(\vec{a}\cdot\vec{b}=\dis{\vec{a}}\dis{\vec{b}}\cos\theta\)</span>。</p><p>证明：既然有了单位向量点积的关系，我们不如将这两个向量转化为单位向量。显然<spanclass="math inline">\(\dfrac{1}{\dis{\vec{a}}}\vec{a},\dfrac{1}{\dis{\vec{b}}}\vec{b}\)</span>都是单位向量，而且夹角的大小不变。因此 <spanclass="math inline">\((\dfrac{1}{\dis{\vec{a}}}\vec{a})\cdot(\dfrac{1}{\dis{\vec{b}}}\vec{b})=\cos\theta\)</span>。再用双线性得<spanclass="math inline">\(\dfrac{1}{\dis{\vec{a}}\dis{\vec{b}}}(\vec{a}\cdot\vec{b})=\cos\theta\)</span>，移项就可以得到<spanclass="math inline">\(\vec{a}\cdot\vec{b}=\dis{\vec{a}}\dis{\vec{b}}\cos\theta\)</span>。这也说明了一点，就是两个向量垂直当且仅当点积等于一，因为这时候<span class="math inline">\(\cos\theta=0\)</span>。</p></li></ol><p>以上两点可以看出，点积和参与运算向量的长度和夹角都有关。为什么呢？<img src="/img/点积1.png" /> 如图，设<spanclass="math inline">\(\vec{a}=\lm x_0\\y_0\rm,\vec{b}=\lm x_1 \\ y_1\rm\)</span>将 <span class="math inline">\(\vec{b}\)</span> 顺时针旋转<span class="math inline">\(90\degree\)</span> 后得到 <spanclass="math inline">\(b^\prime =\lmy_1\\-x_1\rm\)</span>，因此整个阴影四边形的面积就是 <spanclass="math inline">\(\operatorname{det}(\lm y_1 &amp; x_0\\-x_1&amp;y_0 \rm)=y_0y_1-(-x_1x_0)=x_0x_1+y_0y_1\)</span>，恰好是 <spanclass="math inline">\(\vec{a}\cdot\vec{b}\)</span>如果你不懂行列式，也没关系。根据三角函数我们可以知道 <spanclass="math display">\[GD=\dis{\vec{b^\prime}}\sin\alpha=\dis{\vec{b}}\sin\alpha=\dis{\vec{b}}\cos(90\degree-\alpha)=\dis{\vec{b}}\cos\theta\]</span> 所以平行四边形的面积为 <spanclass="math inline">\(\dis{\vec{a}}\dis{\vec{b}}\cos\theta\)</span>。这样就解释了为什么点积和长度，夹角都有关系。<del>行列式不也是吗</del></p><h3 id="应用">应用</h3><p>由于这些神奇的特性，我们可以有点积做一些有趣的事情。 ####正交分解公式也可以叫投影公式，<del>起这个标题只是因为听起来更高大上。</del></p><p>这个公式的作用是这样的：给定两个向量 <spanclass="math inline">\(\vec{a},\vec{b}\)</span>，将 <spanclass="math inline">\(\vec{a}\)</span> 拆成 <spanclass="math inline">\(\vec{a_0}+\vec{a_1}\)</span> 的形式，使得 <spanclass="math inline">\(\vec{a_0}\perp \vec{b},\vec{a_1}\parallel\vec{b}\)</span>。其中一个方法是线性变换，另一个就是点积。</p><p>先给出一个解析几何的方法： 假设 <spanclass="math inline">\(\vec{a}=\vec{a_0}+\vec{a_1}\)</span>，由于 <spanclass="math inline">\(\vec{a_1}\parallel\vec{b}\)</span>，所以我们可以设<span class="math inline">\(\vec{a_1}=k\vec{b}\)</span>，可以得到 <spanclass="math inline">\(\vec{a}=\vec{a_0}+k\vec{b}\)</span>，两边同时点积得<spanclass="math inline">\(\vec{a}\cdot\vec{b}=\vec{a_0}\cdot\vec{b}+k(\vec{b}\cdot\vec{b})\)</span>，由于<span class="math inline">\(\vec{a_0}\perp \vec{b}\)</span>，所以 <spanclass="math inline">\(\vec{a_0}\cdot\vec{b}=0\)</span>。因此 <spanclass="math inline">\(\vec{a}\cdot\vec{b}=k(\vec{b}\cdot\vec{b})\)</span>，<spanclass="math inline">\(k=\dfrac{\vec{a}\cdot\vec{b}}{\vec{b}\cdot\vec{b}}\)</span>。带入得<spanclass="math inline">\(\vec{a_1}=\dfrac{\vec{a}\cdot\vec{b}}{\vec{b}\cdot\vec{b}}\vec{b}\)</span>。<del>这是怎么发现的</del></p><p>再给出一个其他的理解方法： <img src="img/点积2.png" />容易看出，<spanclass="math inline">\(\dfrac{\vec{a}\cdot\vec{b}}{\vec{b}\cdot\vec{b}}\)</span>实际上是 <span class="math inline">\(GD\)</span> 和 <spanclass="math inline">\(OC\)</span> 的比值，等于 <spanclass="math inline">\(OI\)</span> 和 <spanclass="math inline">\(OH\)</span> 的比值（通过三垂直可以知道 <spanclass="math inline">\(\triangle BGO \cong \triangleOGD\)</span>）。因此将这个数乘上 <spanclass="math inline">\(\vec{b}\)</span> 自然就是 <spanclass="math inline">\(\vec{OI}\)</span>，也就是得到的 <spanclass="math inline">\(\vec{a_1}\)</span>，太好了，数学诚不我欺。</p><h4 id="柯西不等式">柯西不等式</h4><p>柯西不等式，又叫Cauchy-Schwarz不等式，指的是这个 <spanclass="math inline">\(\left|\vec{a}\cdot\vec{b}\right|\leq\dis{\vec{a}}\dis{\vec{b}}\)</span>。结合刚才的平行四边形和 <spanclass="math inline">\(\vec{a}\cdot\vec{b}=\dis{\vec{a}}\dis{\vec{b}}\cos\theta\)</span>可以很快推出来，因为 <span class="math inline">\(\cos\theta\)</span> 在<span class="math inline">\([-1,+1]\)</span> 之间，取 <spanclass="math inline">\(\pm 1\)</span> 时当前仅当 <spanclass="math inline">\(\theta=0\degree\)</span>。</p><p>还有另外一种证明方法，就是将 <spanclass="math inline">\(\vec{a}\)</span> 进行正交分解，得 <spanclass="math inline">\(\vec{a}=\vec{a_0}+\vec{a_1}\)</span>。移项得 <spanclass="math inline">\(\vec{a_0}=\vec{a}-\vec{a_1}\)</span>，两边同时点积得<span class="math display">\[\displaylines{\vec{a_0}\cdot\vec{a_0}&amp;=\vec{a_0}\cdot(\vec{a}-\vec{a_1})\\&amp;= \vec{a_0}\cdot\vec{a}-\vec{a_0}\cdot\vec{a_0}\\&amp;= \vec{a_0}\cdot\vec{a}\\&amp;=(\vec{a}-\dfrac{\vec{a}\cdot\vec{b}}{\vec{b}\cdot\vec{b}}\vec{b})\cdot\vec{a}\\&amp;=\vec{a}\cdot\vec{a}-\dfrac{\vec{a}\cdot\vec{b}}{\vec{b}\cdot\vec{b}}(\vec{a}\cdot\vec{b})\\&amp;=\dis{\vec{a}}^2-\dfrac{(\vec{a}\cdot\vec{b})^2}{\dis{\vec{b_0}}^2}=\dis{\vec{a_0}}\geq0}\]</span> 整理得 <span class="math display">\[\displaylines{\dis{\vec{a}}^2-\dfrac{(\vec{a}\cdot\vec{b})^2}{\dis{\vec{b_0}}^2}\geq0\\\dis{\vec{a}}^2\geq \dfrac{(\vec{a}\cdot\vec{b})^2}{\dis{\vec{b_0}}^2}\\\dis{\vec{a}}^2\dis{\vec{b_0}}^2\ge(\vec{a}\cdot\vec{b})^2\\\sqrt{\dis{\vec{a}}^2\dis{\vec{b_0}}^2}\ge\sqrt{(\vec{a}\cdot\vec{b})^2}\\\dis{\vec{a}}\dis{\vec{b_0}}\geq \left|\vec{a}\cdot\vec{b}\right|\\}\]</span> 证毕。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 数学 </category>
          
          <category> 解析几何 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>瞎谈点积</title>
      <link href="/xia-tan-dian-ji/"/>
      <url>/xia-tan-dian-ji/</url>
      
        <content type="html"><![CDATA[<p><spanclass="math inline">\(\newcommand{\lm}{\begin{bmatrix}}\newcommand{\rm}{\end{bmatrix}}\newcommand{\dis}[1]{\left\|#1\right\|}\)</span>从标题可以看出这篇文章时关于点积的。本文讨论的是平面点积。本文记 <spanclass="math inline">\(\vec{a}\)</span> 的长度为 <spanclass="math inline">\(\left\|\vec{a}\right\|\)</span>。</p><p>参与点积运算的是两个向量。架设有两个向量 <spanclass="math inline">\(\vec{a}=\begin{bmatrix}x_0 \\y_0\end{bmatrix},\vec{b}=\begin{bmatrix}x_1 \\y_1\end{bmatrix}\)</span>，则我们定义点积为 <spanclass="math inline">\(\vec{a} \cdot\vec{b}=x_0x_1+y_0y_1\)</span>。点积是一个很神奇的东西，先说它的几条性质。</p><h3 id="性质">性质</h3><h4 id="交换律">交换律</h4><p>对于任意 <span class="math inline">\(\vec{a}=\begin{bmatrix}x_0 \\y_0\end{bmatrix},\vec{b}=\begin{bmatrix}x_1 \\y_1\end{bmatrix}\)</span>，都有 <span class="math inline">\(\vec{a}\cdot \vec{b}=\vec{b} \cdot \vec{a}\)</span>。 证明：显而易见吧。 <spanclass="math display">\[\displaylines{\vec{a} \cdot \vec{b}=x_0x_1+y_0y_1\\\vec{b} \cdot \vec{a}=x_1x_0+y_1y_0=x_0x_1+y_0y_1}\]</span> #### 双线性 双线性意味着一下两点： 1. <spanclass="math inline">\(\vec{a}\cdot(\vec{b}+\vec{c})=\vec{a}\cdot\vec{b}+\vec{a}\cdot \vec{c}\)</span> 2. <spanclass="math inline">\(\vec{a}\cdot(k\vec{b})=k(\vec{a}\cdot\vec{b})\)</span>证明都不难，根据定义展开计算即可，在这里不做赘述。</p><h4 id="正定性">正定性</h4><p><del>其实就是非负性</del></p><p>正定性意味着对于任何向量 <span class="math inline">\(\vec{a}\in\mathbb{R}^2\)</span>，<spanclass="math inline">\(\vec{a}\cdot\vec{a}\geq 0\)</span>。取等号当且仅当<span class="math inline">\(\vec{a}\)</span> 是零向量。</p><p>证明也很简单，假设 <span class="math inline">\(\vec{a}=\lmx\\y\rm\)</span> 注意到 <spanclass="math inline">\(\vec{a}\cdot\vec{a}=x^2+y^2=\dis{\vec{a}}^2\)</span>。显而易见，长度是不能为负的。</p><p>以上就是点积的三条性质，这些性质大多用来参与运算。</p><h3 id="关系">关系</h3><p>这还不是点积最神奇的地方，最神奇的地方在于点积和两个向量的长度和夹角都有关。</p><ol type="1"><li><p>对于单位圆上的向量 <spanclass="math inline">\(\vec{a},\vec{b}\)</span>，其夹角为 <spanclass="math inline">\(\theta\)</span>，都有 <spanclass="math inline">\(\vec{a}\cdot\vec{b}=\cos \theta\)</span>。</p><p>证明：假设向量 <span class="math inline">\(\vec{b}\)</span> 是由<span class="math inline">\(\vec{a}\)</span> 逆时针 <spanclass="math inline">\(\theta\)</span>度之后得到的，由于众所周知，逆时针旋转 <spanclass="math inline">\(\theta\)</span> 度之后 的旋转矩阵是 <spanclass="math inline">\(\lm \cos \theta &amp; -\sin \theta \\ \sin \theta&amp; \cos \theta \rm\)</span>。设 <spanclass="math inline">\(\vec{a}=\lm x\\y\rm\)</span>，那么有 <spanclass="math inline">\(\vec{b}=\vec{a}\lm \cos \theta &amp; -\sin \theta\\ \sin \theta &amp; \cos \theta \rm=\lm x\\y\rm \lm \cos \theta &amp;-\sin \theta \\ \sin \theta &amp; \cos \theta \rm=\lmx\cos\theta-y\sin\theta \\ x\sin\theta+y\cos\theta\rm\)</span>。所以<span class="math display">\[\displaylines{\vec{a}\cdot\vec{b}&amp;=x(x\cos\theta-y\sin\theta)+y(x\sin\theta+y\cos\theta)\\&amp;=x^2\cos\theta-xy\sin \theta+xy\sin \theta +y^2\cos\theta\\&amp;=(x^2+y^2)\cos \theta=\dis{\vec{a}}\cos \theta=\cos \theta}\]</span>证毕。</p></li><li><p><spanclass="math inline">\(\vec{a}\cdot\vec{b}=\dis{\vec{a}}\dis{\vec{b}}\cos\theta\)</span>。</p><p>证明：既然有了单位向量点积的关系，我们不如将这两个向量转化为单位向量。显然<spanclass="math inline">\(\dfrac{1}{\dis{\vec{a}}}\vec{a},\dfrac{1}{\dis{\vec{b}}}\vec{b}\)</span>都是单位向量，而且夹角的大小不变。因此 <spanclass="math inline">\((\dfrac{1}{\dis{\vec{a}}}\vec{a})\cdot(\dfrac{1}{\dis{\vec{b}}}\vec{b})=\cos\theta\)</span>。再用双线性得<spanclass="math inline">\(\dfrac{1}{\dis{\vec{a}}\dis{\vec{b}}}(\vec{a}\cdot\vec{b})=\cos\theta\)</span>，移项就可以得到<spanclass="math inline">\(\vec{a}\cdot\vec{b}=\dis{\vec{a}}\dis{\vec{b}}\cos\theta\)</span>。以上两点可以看出</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> OI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STAOI G Round 4 T1题解</title>
      <link href="/ti-jie/staoi-g-round-4-t1-ti-jie/"/>
      <url>/ti-jie/staoi-g-round-4-t1-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="特解">特解</h2><p>先来考虑方程 <span class="math inline">\(\begin{cases}x+y=A\\x\operatorname{AND} y =B\end{cases}\)</span> 的一组特解。由于按位与<strong>不进位</strong>，并且 <span class="math inline">\(a\operatorname{AND} b=1\)</span> 当且仅当 <spanclass="math inline">\(a=b=1\)</span> ,这意味这 <spanclass="math inline">\(B\)</span> 的二进制中有一位为 <spanclass="math inline">\(1\)</span>，<spanclass="math inline">\(x,y\)</span> 相应的位上必定也为 <spanclass="math inline">\(1\)</span>，如果这位是 <spanclass="math inline">\(0\)</span>，那么只要保证 <spanclass="math inline">\(x,y\)</span> 中相应的位上不同时为 <spanclass="math inline">\(1\)</span> 就行。因此，我们可以先构造出一个满足<span class="math inline">\(a \operatorname{AND} b=B\)</span>的最小解，方法是： - 将 <spanclass="math inline">\(B\)</span> 进行二进制分解，枚举其中的每一位。 -如果这一位为 <span class="math inline">\(1\)</span>，则把 <spanclass="math inline">\(a,b\)</span> 相应的位上变为 <spanclass="math inline">\(1\)</span>。 - 如果这一位是 <spanclass="math inline">\(0\)</span>，就把 <spanclass="math inline">\(a,b\)</span> 中相应的位保持 <spanclass="math inline">\(0\)</span>。 最后得到的 <spanclass="math inline">\(x,y\)</span> 就是满足 <spanclass="math inline">\(a \operatorname{AND} b =B\)</span> 并且最小的<span class="math inline">\(a,b\)</span>。此时，我们改变 <spanclass="math inline">\(a\)</span> 中任意一位为 <spanclass="math inline">\(0\)</span> 的位并不会改变 <spanclass="math inline">\(a \operatorname{AND} b\)</span> 的值，而改变第<span class="math inline">\(i\)</span> 位相当于给这个数加上 <spanclass="math inline">\(2^{i-1}\)</span>，我们可以通过改变这些 <spanclass="math inline">\(0\)</span> 位来补齐 <spanclass="math inline">\(a+b\)</span> 和 <spanclass="math inline">\(A\)</span> 之间的差值。 设 <spanclass="math inline">\(a\)</span> 的二进制分解为 <spanclass="math inline">\(\overline{a_1a_2\cdots a_n}\)</span>，差值 <spanclass="math inline">\(c\)</span> 的二进制分解为 <spanclass="math inline">\(\overline{b_1b_2\cdotsc_m}\)</span>。显然，差值可以被补齐当且仅当 <spanclass="math inline">\(\forall i,b_i=1\)</span> 都有 <spanclass="math inline">\(a_i=0\)</span>，否则这一位无法被补齐。因此，我们只要检验<span class="math inline">\((a+c) \operatorname{AND} b\)</span>是否仍等于 <span class="math inline">\(B\)</span> 就行了，如果可以，那么<span class="math inline">\(x=a+c,y=b\)</span> 就是一组特解，否则无解。## 齐次解 假设已经求出一组解 <spanclass="math inline">\(x,y\)</span>，设 <spanclass="math inline">\(x=(\overline{x_1x_2\cdotsx_n})_2,y=(\overline{y_1y_2\cdots y_n})_2\)</span>（不足的位向高位填<span class="math inline">\(0\)</span>补齐）。我们通过观察样例可以发现，如果 <spanclass="math inline">\(x_i,y_i\)</span> 一个为 <spanclass="math inline">\(1\)</span>，另一个为 <spanclass="math inline">\(0\)</span>，此时交换这两个数既不会改变 <spanclass="math inline">\(x \operatorname{AND} y\)</span>，也不会改变 <spanclass="math inline">\(x+y\)</span>，也就是说，交换这两位后的 <spanclass="math inline">\(x,y\)</span> 是一组不同的解。为了满足 <spanclass="math inline">\(x\ley\)</span>，我们只要保持最高的满足上面条件的两位保持不变，只交换后面不同的两位。</p><h2 id="求和">求和</h2><p>接下来不妨设共有 <span class="math inline">\(n\)</span>个不同位，<span class="math inline">\(x_i,y_i\)</span>是其中一组不同位（不是最高的一位 ）。由加乘原理可以得知，一共由 <spanclass="math inline">\(2^n\)</span> 组解。其中，<spanclass="math inline">\(x_i=1,y_i=0\)</span> 的解有 <spanclass="math inline">\(2^{n-1}\)</span> 种，反过来也有 <spanclass="math inline">\(2^{n-1}\)</span> 种。在计算 <spanclass="math inline">\(y-x\)</span> 时，第一种情况会计算为 <spanclass="math display">\[\displaylines{(\overline{x_1x_2\cdots 1 \cdotsx_n})_2-(\overline{y_1y_2\cdots 0 \cdotsy_n})_2\\=(\overline{x_1x_2\cdots 0 \cdotsx_n})_2-(\overline{y_1y_2\cdots 0 \cdotsy_n})+(1-0)*2^{n-i}\\=(\overline{x_1x_2\cdots 0 \cdotsx_n})_2-(\overline{y_1y_2\cdots 0 \cdotsy_n})+2^{n-i}}\]</span>后一种情况会计算为 <spanclass="math display">\[\displaylines{(\overline{x_1x_2\cdots 0 \cdotsx_n})_2-(\overline{y_1y_2\cdots 1 \cdotsy_n})_2\\=(\overline{x_1x_2\cdots 0 \cdotsx_n})_2-(\overline{y_1y_2\cdots 0 \cdotsy_n})+(0-1)*2^{n-i}\\=(\overline{x_1x_2\cdots 0 \cdotsx_n})_2-(\overline{y_1y_2\cdots 0 \cdotsy_n})-2^{n-i}}\]</span>两者在相加时抵消。其它不同位也一样。因此，最后不同位并不会对最终答案有影响，最终答案是将<span class="math inline">\(x,y\)</span> 除去不同位后相减，在乘上 <spanclass="math inline">\(2^n\)</span>，最后对 <spanclass="math inline">\(m\)</span> 取模后的结果。 ## AC Code<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">65</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> a,m,t;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function">bitset&lt;N&gt; <span class="hljs-title">binary_fact</span><span class="hljs-params">(ull a)</span></span>&#123; <span class="hljs-comment">//二进制分解</span><br>    bitset&lt;65&gt; ret;<br>    <span class="hljs-keyword">for</span>(ull i=<span class="hljs-number">0</span>;a;a&gt;&gt;=<span class="hljs-number">1</span>,i++)&#123;<br>        ret[i]=a&amp;<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">lpow</span><span class="hljs-params">(ull a,ull b,ull p)</span></span>&#123; <span class="hljs-comment">//快速幂</span><br>    ull ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(ull i=<span class="hljs-number">1</span>;b;b&gt;&gt;=<span class="hljs-number">1</span>,i*=<span class="hljs-number">2</span>)&#123;<br>        ans*=<span class="hljs-built_in">pow</span>(a,(b&amp;<span class="hljs-number">1</span>)*i);<br>        ans=ans%m;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">alyze</span><span class="hljs-params">(<span class="hljs-type">const</span> bitset&lt;N&gt;&amp; a,<span class="hljs-type">const</span> bitset&lt;N&gt;&amp; b)</span></span>&#123; <span class="hljs-comment">//求出所有不同位的下标</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]^b[i])x.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!x.<span class="hljs-built_in">empty</span>())x.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">cau</span><span class="hljs-params">(bitset&lt;N&gt; a,bitset&lt;N&gt; b,vector&lt;<span class="hljs-type">int</span>&gt; al)</span></span>&#123; <span class="hljs-comment">//求结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:al)&#123;<br>        a[x]=b[x]=<span class="hljs-number">0</span>;<br>    &#125;<br>    ull x=a.<span class="hljs-built_in">to_ullong</span>(),y=b.<span class="hljs-built_in">to_ullong</span>();<br>    ull ans=((<span class="hljs-built_in">max</span>(x,y)-<span class="hljs-built_in">min</span>(x,y))%m)*(<span class="hljs-built_in">lpow</span>(<span class="hljs-number">2</span>,al.<span class="hljs-built_in">size</span>(),m));<br>    <span class="hljs-keyword">return</span> ans%m;<br>&#125;<br><br><span class="hljs-function">pair&lt;ull,ull&gt; <span class="hljs-title">spe_sol</span><span class="hljs-params">(bitset&lt;N&gt; a,bitset&lt;N&gt; b)</span></span>&#123; <span class="hljs-comment">//特解</span><br>    ull x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">if</span>(b[i]==<span class="hljs-number">1</span>)x+=(<span class="hljs-number">1ull</span>&lt;&lt;i),y+=(<span class="hljs-number">1ull</span>&lt;&lt;i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x+y&gt;a.<span class="hljs-built_in">to_ullong</span>())<span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> t=a.<span class="hljs-built_in">to_ullong</span>()-x-y;<br>    <span class="hljs-keyword">if</span>(((x+t)&amp;y)!=b.<span class="hljs-built_in">to_ullong</span>())<span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(x+t,y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cin&gt;&gt;t&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(ull i=<span class="hljs-number">0</span>;i&lt;t;i++)&#123;<br>        ull a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">auto</span> z=<span class="hljs-built_in">spe_sol</span>(<span class="hljs-built_in">binary_fact</span>(a),<span class="hljs-built_in">binary_fact</span>(b));<br>        bitset&lt;N&gt; p=z.first,q=z.second;<br>        vector&lt;<span class="hljs-type">int</span>&gt; k=<span class="hljs-built_in">alyze</span>(p,q);<br>        cout&lt;&lt;<span class="hljs-built_in">cau</span>(p,q,k)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划入门指北</title>
      <link href="/dong-tai-gui-hua-ru-men-zhi-bei/"/>
      <url>/dong-tai-gui-hua-ru-men-zhi-bei/</url>
      
        <content type="html"><![CDATA[<h3 id="从搜索的优化说起">从搜索的优化说起</h3><p>考虑这样题目：&gt;写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。<img src="/img/95pzs0ne.png" alt="来源：洛谷" /></p><p>显然，我们可以从顶端开始，枚举每一条路径，求出其中的最大值。我们注意到，如果有一条路径可以到达某个点，之前的路径并不会影响之后走的路径。</p><p>举个例子：假如通过 <span class="math inline">\(7-8-1\)</span> 到达了<span class="math inline">\(1\)</span> 这个点，接下来打算走 <spanclass="math inline">\(1-4-6\)</span> 这几个点到达 <spanclass="math inline">\(6\)</span> 这个点，但加入你通过 <spanclass="math inline">\(7-3-1\)</span> 到达 <spanclass="math inline">\(1\)</span> 这个点，仍然可以走 <spanclass="math inline">\(1-4-6\)</span> 到达 <spanclass="math inline">\(6\)</span>。</p><p>因此，此时到达 <span class="math inline">\(1\)</span>的最优解在最后肯定比到达 <span class="math inline">\(1\)</span>的其它路径更优。因为之后无论什么路径，最有解和其他路径都可以走，而最优解有优于其他路径，因此肯定更优。比如图中<span class="math inline">\(7-8-1-7-5\)</span> 肯定比 <spanclass="math inline">\(7-3-1-7-5\)</span> 更优，因为到达 <spanclass="math inline">\(1\)</span> 这个点的路径更优。</p><p>所以，到达每个点的最优解只和到达上一个点的最优解有关。所以刚刚的搜索算法多了许多无效搜索。因为每个点的前面一个点只有两种可能（左和右两个点，最优解记作<span class="math inline">\(p_l\)</span>和<spanclass="math inline">\(p_r\)</span>）因此，如果将当前的数字记作 <spanclass="math inline">\(p_{rec}\)</span>，到达下一个点的最优路径为 <spanclass="math inline">\(\operatorname{max}(p_l,p_r)+p_{rec}\)</span>。我们只要枚举每层每个点，像这样求出最优解即可。像这样的算法叫做动态规划（DynamicProgramming，简称DP）。</p><h3 id="动态规划简介">动态规划简介</h3><p>接下来更加详细的介绍动态规划算法。 #### 概念解释 1.在上面的例子中，求出 <span class="math inline">\(p_{rec}\)</span>要先求出 <span class="math inline">\(p_l\)</span> 和 <spanclass="math inline">\(p_r\)</span>。我们将求出 <spanclass="math inline">\(p_l,p_r\)</span> 称为 <spanclass="math inline">\(p_{rec}\)</span>的”子问题“，通常，子问题是一个数据规模更小的相同问题。<br />2. 在上文中，我们用点上的数字来描述一个问题，比如“到编号为 <spanclass="math inline">\(1\)</span>的点的最有解”，但实际上可能会优重复，而且查找并不方便。因此我们可以用行号列号来描述一个问题。比如“到第<span class="math inline">\(3\)</span> 行第 <spanclass="math inline">\(2\)</span>个点的最优解”。像这样描述一个子问题，叫做“状态”。 3.在上面的例子中，我们按照行号枚举每个点。在这里，我们将一行的点分为一类，从上到下枚举。其中一类被称为动态规划的阶段，设计阶段时要保证，在解决一个问题前，要保证问题的所有子问题都被正确解决。4. 上文的 <spanclass="math inline">\(\operatorname{max}(p_l,p_r)+p_{rec}\)</span>描述了如何从一个状态的到下一个状态（从子问题的最优解推导出问题的最优解），被称为“状态转移方程”。</p><p>接下来考虑动态规划要满足的条件： #### 最优子结构所谓最优子结构，是指以下两点 1.到达每个状态前做出的决策并不会影响之后做出的决策（对应上文如果有一条路径可以到达某个点，之前的路径并不会影响之后走的路径）2.问题的最优解一定来自于子问题的最优解（对应上文到达每个点的最优解只和到达上一个点的最优解有关）</p><h4 id="无后效性">无后效性</h4><p>无后效性是指，一个子问题的答案只依赖于在它之前解决子问题，不会受在它之后解决的子问题的影响。</p><p>在开头的例子中，经过了一个点是不能往回走到，因此满足无后效性。</p><h4 id="重叠子问题">重叠子问题</h4><p>重叠子问题是指，要解决多个问题往往依赖于一些相同的子问题。比如开头的例子中，求第<span class="math inline">\(3\)</span> 行第 <spanclass="math inline">\(1\)</span> 和第 <spanclass="math inline">\(2\)</span> 个数都依赖于第 <spanclass="math inline">\(2\)</span> 行第 <spanclass="math inline">\(1\)</span>个数的最优解。重叠子问题越多，dp算法效率越高。</p><h3 id="和其他算法的关系">和其他算法的关系</h3><h4 id="分治">分治</h4><p>DP可以看作是一种分治算法，将一个问题分解成多个子问题，当子问题足够容易解决时解决掉这些子问题，再用状态转移方程得到问题答案。 分治算法通常用递归来实现，我们也可以写出DP的递归写法（以开头的数字三角形为例）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">slove</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dp[i][j]!=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> dp[i][j];<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> dp[i][j]=arr[i][j];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dp[i][j]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">slove</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>),<span class="hljs-built_in">slove</span>(i<span class="hljs-number">-1</span>,j))+arr[i][j];<br>&#125;<br></code></pre></td></tr></table></figure>递归的运算次数再某些情况下会略小于接下来要说的递推写法，但是由于函数调用需要花时间，并且递归层数过深容易爆栈，因此采用递归写法实际上不一定比递推更优。</p><h4 id="递推">递推</h4><p>实际上，按阶段枚举每个点和递推也很是相似，都是通过子问题的解推出问题的解。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>        dp[i+<span class="hljs-number">1</span>][j]=<span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i][j]+arr[i+<span class="hljs-number">1</span>][j]);<br>        dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>],dp[i][j]+arr[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 也可以这样写： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j])+arr[i][j];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>两种方法并没有太大的区别。</p><p>实际上不难发现，递归写法和递推的第二种写法是从问题的角度出发，而递归的第一种写法是从子问题推导出问题的解的角度出发的。</p><h4 id="图论">图论</h4><p>DP与图论关系很大，图论中的Floyd算法和Dijkstra算法都采用的DP的思想。</p><p>实际上，如果将状态看作图上的点，将状态之间的关系看作边，那么DP实际上就是再一张图上用BFS跑最短路/最长路。BFS第一次访问的节点（第一层）就是DP的第一阶段。以次类推。</p><p>由于DP的特性无后效性，所以图中显然没有环，因此这个算法是正确的。 这也引出了有后效性的一个常见做法：利用SPFA算法的迭代思想，多次迭代到某个状态的最优解。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> OI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>凸透镜与凹透镜</title>
      <link href="/tu-tou-jing-yu-ao-tou-jing/"/>
      <url>/tu-tou-jing-yu-ao-tou-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="凸透镜">凸透镜</h2><h3 id="成像原理">成像原理</h3><blockquote><p>关于实像和虚像的定义，请参见<ahref="http://%5B2409:8a20:c83:2f20:e594:587d:830c:4a90%5D:8001/shi-xiang-he-xu-xiang/">实像和虚像</a></p></blockquote><p>众所周知，凸透镜有聚光的作用。 1.在一倍焦距以内，一个点光源发出的光线最后是这样的： <imgsrc="/img/凸透镜1.png" />此时经过凸透镜的光线的反射延长线交于H点，这个点光源会在H点成虚像。由于光线会比原来汇聚，所以H点到透镜的距离会大于点光源到透镜的距离。2. 当点光源位于一倍焦距之外是，光线是这个样子的。 <imgsrc="/img/凸透镜2.png" />此时经过凸透镜的光线会交于J点，再J点放置光屏，可以再光屏上成实像（即，J点会成点光源的实像）。这时，如果再J点右侧观察，J点相当于一个点光源（但是并不是点光源，只是有相同的效果）。注：其实并不是只有一个点光源发出的光线会像这样汇聚成一点，满足这些条件的光线可以不是从同一个光源上发出的，但是这些光线一定是等价于一个点光源发出的光线（折射时光路可逆），因此，我们可以用这些点光源代替这些光线。</p><p>有了这些知识，我们就可以理解凸透镜的成像原理了。 1. <spanclass="math inline">\(u\ltf\)</span>时（方便起见<del>就是懒</del>，以后只保留关键光路） <imgsrc="/img/凸透镜3.png" />每个光源上的点光源会在同侧成虚像，点光源的所有虚像一起构成了光源的虚像。2. <span class="math inline">\(u\gt f\)</span>时 <imgsrc="/img/凸透镜4.png" />光源上的每个点光源发出的光线经过透镜后汇聚在另一侧的一个点上，这些点一起构成了实像（即，在另一侧成实像），在像的右侧，会有一个等效与光源的”光源“，有每个点光源的等效光源组成。最后，关于眼睛看到的东西： 1. 成虚像时：看到的就是虚像。 2.成实像时：在实像右侧时，由于每个点光源会在右侧形成一个等效的“点光源”，眼球会调节焦距直到这些“点光源”在视网膜上成实像，这些“点光源”在视网膜上一起构成了光源的像，所以我们可以透过凸透镜看见像（像的位置就是实像所在的位置）。在实像左侧观测时，光路不等价与任何点光源发出的光路，所以大脑无法处理这些光路，什么像都观测不到。为什么只能透过透镜看到部分像？假设眼睛在T点，那么这些光线是眼睛可以看到的（光路保留临界光线）： <imgsrc="/img/凸透镜5.png" /> 这些是看不到的： <imgsrc="/img/凸透镜6.png" /> 所以只能看到一部分。</p><h3 id="焦距物距和相距">焦距、物距和相距</h3><p>对于凸透镜来说，焦距<span class="math inline">\(f\)</span>、物距<spanclass="math inline">\(u\)</span>和相距<spanclass="math inline">\(v\)</span>有这样的关系： <spanclass="math display">\[\dfrac{1}{u}+\dfrac{1}{v}=\dfrac{1}{f}\]</span> 证明：还是这张图 <img src="/img/凸透镜7.png" /> <spanclass="math display">\[\displaylines{物距u=BO,相距v=B&#39;O,焦距f=OF=OF&#39; \\易证\triangle{ABO}\sim\triangle{A&#39;B&#39;O}且\triangle{HOF&#39;}\sim\triangle{A&#39;B&#39;F&#39;}\\\therefore AB:A&#39;B=BO:B&#39;O=u:v,\\HO:A&#39;B&#39;=OF&#39;:B&#39;F&#39;=f:v-f\\\because AB=HO\\\therefore AB:A&#39;B=HO:A&#39;B\\\therefore u:v=f:(v-f)\\vf=u(v-f)\\vf=uv-uf\\vf+uf=uv\\(u+v)f=uv\\u+v=\dfrac{uv}{f}\\\dfrac{u+v}{uv}=\dfrac{1}{f}\\\dfrac{1}{u}+\dfrac{1}{v}=\dfrac{1}{f}}\]</span></p><h3 id="眼球">眼球</h3><p>晶状体本质上是一个凸透镜，外界光源通过这个透镜将像成在视网膜上，由感光细胞接受，由大脑处理形成了视觉。和所有凸透镜成像一样，最后在视网膜上成一个点的像不一定来自于一个点光源，最后的像也不一定是由实际的物发出的，眼睛只关心最后入眼的光线汇聚再视网膜上能不能成清晰的像。但是，如果可以，那么此时入眼的光线仍等价与一个光源的光线（既然等价，自然成的像一样，所以我们一般用这个光源来代替入眼光线）。</p><h3 id="显微镜和望远镜">显微镜和望远镜</h3><h4 id="原理">原理</h4><p>这两个原理是一样的，都是凸透镜组合，我们把靠近物的叫做物镜，另一个叫做目镜。物镜成实像，将在透镜右侧形成一个等效的”光源“（实像），目镜成”光源“的放大的虚像（起放大的作用）。为什么一定要用透镜组？ 1.单个透镜成实像：作为望远镜时，并不能起到望远的作用，因为像时缩小的（参见凸透镜成像规律）。作为显微镜，显然放大倍数不够大（或足够大的难以生产），而且不方便观测（人不一定在像的外侧，要人左右移动）。2. 单个透镜成虚像：对于两者：放大倍数都不够大（况且虚像会比原来远）。为什么一定要采用这种形式？如果物镜成虚像，由于凸透镜成虚像到透镜的距离会较物距更远，不便控制第二个目镜在放大倍数够大时一定成虚像。如果目镜成实像，那么观测时不一定在像的右侧，看到实像，需要人来回移动（而且有时实像很远），也不方便。#### 大于两个透镜组合只要保证最后一个凸透镜成虚像，剩下的成实像，保证凸透镜之间的距离即可。</p><h4 id="透镜间距离">透镜间距离</h4><p>记相邻2个透镜距离<spanclass="math inline">\(d\)</span>.透镜1焦距<spanclass="math inline">\(f_1\)</span>，透镜2焦距<spanclass="math inline">\(f_2\)</span>，物距相距同理。 清晰范围：指将<spanclass="math inline">\(d\)</span>调节到该范围可以得到清晰的像（这个范围需要保证透镜1成的像在透镜2的成像范围之内）。可调节范围：指对于每一个物距<spanclass="math inline">\(u_1\)</span>，都能在这个范围内调节<spanclass="math inline">\(d\)</span>得到清晰的像。（就是在设计显微镜和望远镜时，设定的<spanclass="math inline">\(d\)</span>可以调整的范围）。 ##### 望远镜清晰：<span class="math inline">\(v_1\lt d\ltv_1+f_2\)</span>（范围内改变会导致虚像大小改变） 可调节范围（假设<spanclass="math inline">\(u_1\gt 2f_1\)</span>）<spanclass="math inline">\(f_1\lt d\lt 2f_1+f_2\)</span> ##### 显微镜清晰：<span class="math inline">\(v_1\lt d\ltv_1+f_2\)</span>（范围内改变会导致虚像大小改变） 可调节范围（假设<spanclass="math inline">\(f_1\lt u_1\lt 2f_1\)</span>）<spanclass="math inline">\(d\gt 2f_1\)</span> ##### 多个透镜组合清晰：对于任意两个相邻的透镜（不包括倒数第一个和倒数第二个，即，两个透镜都成实像）都有<spanclass="math inline">\(v_1+f_2\ltd\)</span>（范围内改变会导致第二个镜头成的实像和<spanclass="math inline">\(v_2\)</span>改变,第二个透镜成放大像是有<spanclass="math inline">\(v_1+f_2\lt d\ltv_1+2f_2\)</span>,成缩小像时有<span class="math inline">\(d\gtv_1+2f_2\)</span>），对于最后两个透镜，满足<spanclass="math inline">\(v_1\lt d\lt v_1+f_2\)</span>。可调节范围：对于两个成实像的透镜，<span class="math inline">\(f_1+f_2\ltd\)</span>，对于最后两个透镜，<span class="math inline">\(d\gt2f_1\)</span>.</p><h2 id="凹透镜">凹透镜</h2><p>与凸透镜成虚像时差不多，只是相距小于物距，大小缩小，并且只成虚像。</p><h3 id="视力矫正">视力矫正</h3><p>近视眼看不起远处的物体，就让凹透镜将像成近一些（<spanclass="math inline">\(v\lt u\)</span>），就可以看清楚了。远视眼看不起近处的物体，就让凸透镜将像成远一些（<spanclass="math inline">\(u\gt v\)</span>），就可以看清楚了。</p>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
          <category> 物理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实像和虚像</title>
      <link href="/shi-xiang-he-xu-xiang/"/>
      <url>/shi-xiang-he-xu-xiang/</url>
      
        <content type="html"><![CDATA[<h3 id="实像">实像</h3><p>具体定义见物理课本。考虑实像的形成。我们将物看作许多个点光源，不难看出，成清晰实像形成的条件是从每个点光源上发出的光线会在光屏上投射要一个点上，如果不是一个点（而是一个光斑）成的像就会不清晰。### 虚像 具体定义还是看物理课本。以平面镜为例，一般来说，会有这样的光路图。</p><p><img src="/img/平面镜1.png" alt="平面镜1.png" />怎么理解？经过平面镜反射后的光路，等价于撤去平面镜后位于C‘点的点光源发出的光线，C'点就是虚像的位置（既然等价，我们的大脑自然会认为C'点有东西了，这就是所谓虚像）。再举一个例子： <img src="/img/凸透镜3_1.png" alt="凸透镜3_1.png" />光源（实箭头）成的虚像（虚箭头）意味着，光源发出的经过凸透镜后的光线相当于撤去凸透镜后，在虚像处放置一个与虚像等大的光源发出的光路，所以大脑会认为虚像处有东西，看到虚像。</p>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
          <category> 物理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小孔成像</title>
      <link href="/xiao-kong-cheng-xiang/"/>
      <url>/xiao-kong-cheng-xiang/</url>
      
        <content type="html"><![CDATA[<p>小孔成像，顾名思义，就是再光源和光屏之间放一个小孔，观察光源的成像效果。发现小孔再光屏上成倒立实像。</p><p>我们再[[实像和虚像]]里曾讨论过实像的形成，小孔成像是怎么实现的？很简单，把点光源发出的其他光线挡住，只留下一束光线打在光屏上。<img src="img/小孔成像2.png" /></p><p><img src="img/小孔成像3.png" />这样就做到了每个点光源上发出的光线会在光屏上投射要一个点上。</p><p>严格意义来说，其实并不是一个点，构成像的单位（即，每个点光源投射到光屏上的形状）是孔的形状（而不是一个点）。像有许多个”单位“构成（光源上的每个点光源都会留下一个）。这样就可以解释许多现象，比如将孔遮去一部分（或改变孔的大小）只会改变构成像的”单位“，减少打到光屏上光的数量，不会使像不完整或大小产生改变。大孔成斑是因为一个单位太大，分辨不出像的形状（极度模糊）。</p><blockquote><p>其实还有一种理解，就是光源通过孔上的每一个点会再光屏上成一个像，光源的像有一个个的这样的像组成，也能解释。比如大孔成斑是因为这样像太小，分辨不出来。其他类似。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
          <category> 物理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>勾股定理</title>
      <link href="/shu-lun/gou-gu-ding-li/"/>
      <url>/shu-lun/gou-gu-ding-li/</url>
      
        <content type="html"><![CDATA[<p>本篇笔记探究<span class="math inline">\(a^2+b^2=c^2\)</span>的通解。方程齐次:<span class="math inline">\(a^2+b^2=c^2\Rightarrow(\lambdaa)^2+(\lambda b)^2=(\lambda c)^2\)</span> 不妨设<spanclass="math inline">\(a,b,c\in\mathbb{N}_1\)</span>且<spanclass="math inline">\(gcd(a,b,c)=1\)</span>. 则有 <spanclass="math display">\[\begin{cases}a=r^2-s^2\\b=2rs\\c=r^2+s^2\end{cases}\]</span> 或<span class="math inline">\(a,b\)</span>互换。 证明： 1.a,b,c两奇一偶 因为<span class="math inline">\((2n)^2=4n^2\equiv0(mod4),(2n+1)^2=4n^2+4n+1\equiv1(mod 4) (n\in\mathbb{N_0})\)</span>. 而<spanclass="math inline">\(a^2+b^2=c^2\Rightarrow a^2+b^2\equivc^2(mod\space4)\)</span> 又因为<spanclass="math inline">\(a,b,c\)</span>两两互质，所以只有当<spanclass="math inline">\(a,b\)</span>一奇一偶，<spanclass="math inline">\(c\)</span>为奇数时有<spanclass="math display">\[a^2+b^2\equiv c^2\equiv1(mod4)\]</span>之后不妨设<span class="math inline">\(b\)</span>为偶。 2. 分解因式。<span class="math display">\[a^2=c^2-b^2=(c+b)(c-b)\]</span></p><p>(记n的质因数分解中p的幂次为<spanclass="math inline">\(V_p(n)\)</span>) 所以对于<spanclass="math inline">\(a^2\)</span>的每个质因子p，有 <spanclass="math display">\[V_p(a^2)=2V_p(a)=V_p(c+b)+V_p(c-b)\]</span> 3. <span class="math inline">\(c+b,c-b\)</span>互素由九章算术·更损相减术可知<spanclass="math inline">\(c+b,c-b\)</span>互素（即，<spanclass="math inline">\(c+b,c-b\)</span>没有公共质因子） <spanclass="math display">\[\displaylines{gcd(c+b,c-b)\\=gcd((c+b)-(c-b),c-b)\\=gcd(2b,c-b)\\=gcd(b,c-b)(c-b为奇）\\=gcd(b,c)\\=1}\]</span></p><p>所以 <span class="math display">\[V_p(c+b)=2V_p(a),V_p(c-b)=0\]</span> 或</p><p><span class="math display">\[V_p(c-b)=2V_p(a),V_p(c+b)=0\]</span> 无论如何，<spanclass="math inline">\(c+b,c-b\)</span>都是平方数（每个质因子的幂次都是<spanclass="math inline">\(2\)</span>的倍数）。 于是我们设<spanclass="math inline">\(n^2=c+b,m^2=c-b\)</span> <spanclass="math display">\[\begin{cases}a=nm=(\dfrac{n+m}{2})^2-(\dfrac{n-m}{2})^2\\b=\dfrac{n^2-m^2}{2}=2·\dfrac{n+m}{2}·\dfrac{n-m}{2}\\c=\dfrac{n^2+m^2}{2}=(\dfrac{n+m}{2})^2+(\dfrac{n-m}{2})^2\end{cases}\]</span> 此时再设<spanclass="math inline">\(r=\dfrac{n+m}{2},s=\dfrac{n-m}{2}\)</span>就有<span class="math display">\[\begin{cases}a=r^2-s^2\\b=2rs\\c=r^2+s^2\end{cases}\]</span> 其实最开始分解因式时写成<spanclass="math inline">\(b^2=(c+a)(c-a)\)</span>会更简单一点，大致思路差不多。#丢番图方程 #勾股定理 ## 同余数 一个数<spanclass="math inline">\(n\in\mathbb{R}\)</span>是同余数当且仅当一下方程组有正整数解。<span class="math display">\[\begin{cases}a^2+b^2=c^2\\n=\frac{1}{2}ab\end{cases}\]</span> 因为<span class="math inline">\(a^2+b^2=c^2\)</span>的通解为<span class="math display">\[\begin{cases}a=r^2-s^2\\b=2rs\\c=r^2+s^2\end{cases}\]</span> 此时有 <span class="math display">\[n=\dfrac{1}{2}ab=\dfrac{1}{2}(r^2-s^2)(2rs)=rs(r^2-s^2)\]</span> 这就是同余数n的通解。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 数学 </category>
          
          <category> 数论 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
